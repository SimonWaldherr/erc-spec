{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\\newpage Executable Research Compendium \u00b6 This is the technical specification of the Executable Research Compendium (ERC). Read the specification ( PDF download ) and get support . Guides \u00b6 Are you a scientist and want to publish your research as an ERC? Read user guides for authors, reviewers, and readers : ERC creation ERC examination ERC template Are you a developer or architect and want to build applications using ERCs? Read our developer documentation: Developer guide o2r System Architecture Are your a librarian or preservationist and want to use ERCs for archival of scholarly works? Read user guides for librarians and preservationists : ERC & OAIS \\newpage Credits \u00b6 This specification and guides are developed by the members of the DFG-funded project Opening Reproducible Research To cite this specification please use N\u00fcst, Daniel, 2018. Reproducibility Service for Executable Research Compendia: Technical Specifications and Reference Implementation. Zenodo. doi: 10.5281/zenodo.2203844 For a complete list of publications, posters, presentations, and software projects from th2 o2r project please visit https://o2r.info/results/ . License \u00b6 The o2r Executable Research Compendium specification is licensed under Creative Commons CC0 1.0 Universal License , see file LICENSE . To the extent possible under law, the people who associated CC0 with this work have waived all copyright and related or neighboring rights to this work. This work is published from: Germany. Build @@VERSION@@ @ @@TIMESTAMP@@","title":"Home"},{"location":"#executable-research-compendium","text":"This is the technical specification of the Executable Research Compendium (ERC). Read the specification ( PDF download ) and get support .","title":"Executable Research Compendium"},{"location":"#guides","text":"Are you a scientist and want to publish your research as an ERC? Read user guides for authors, reviewers, and readers : ERC creation ERC examination ERC template Are you a developer or architect and want to build applications using ERCs? Read our developer documentation: Developer guide o2r System Architecture Are your a librarian or preservationist and want to use ERCs for archival of scholarly works? Read user guides for librarians and preservationists : ERC & OAIS \\newpage","title":"Guides"},{"location":"#credits","text":"This specification and guides are developed by the members of the DFG-funded project Opening Reproducible Research To cite this specification please use N\u00fcst, Daniel, 2018. Reproducibility Service for Executable Research Compendia: Technical Specifications and Reference Implementation. Zenodo. doi: 10.5281/zenodo.2203844 For a complete list of publications, posters, presentations, and software projects from th2 o2r project please visit https://o2r.info/results/ .","title":"Credits"},{"location":"#license","text":"The o2r Executable Research Compendium specification is licensed under Creative Commons CC0 1.0 Universal License , see file LICENSE . To the extent possible under law, the people who associated CC0 with this work have waived all copyright and related or neighboring rights to this work. This work is published from: Germany. Build @@VERSION@@ @ @@TIMESTAMP@@","title":"License"},{"location":"glossary/","text":"Glossary \u00b6 (Computational) Analysis \u00b6 A scientific workflow that is to be preserved in an ERC. It conducts a number of operations on data and generates an output (text, numbers, plots). Bag \u00b6 See BagIt specification . A set of opaque data contained within the structure defined by this specification. Compendium contents \u00b6 See ERC contents Container \u00b6 A receptacle holding a collection of things (\u201cpayload\u201d or \u201ccontents\u201d). In the context of this specification, two containers are distinguished: runtime container and outer container . Check \u00b6 A subconstituent of Examine . Checking an ERC is a syntactical validation, which may be largely automated by a software tool reporting the check result and potential errors. A check comprises (a) the validation of a concrete ERC against the ERC specification, e.g. are required files and metadata fields present, and (b) an execution of the contained analysis. The execution includes a comparison of the result files in the just executed inner container with the result stored in the outer container. Create \u00b6 One of the major constituents of ERC interaction. The user can create an ERC by following the technical instructions included in the Specification (ERC Spec) or use the o2r reproducibility service. For more information, see erc-spec/user-guide/creation/ . Discover \u00b6 One of the major constituents of ERC interaction. Discovery comprises the findability of the ERC as well as the exploration of its features, e.g. time and space driven search operations. ERC \u00b6 Executable Research Compendium, see article . ERC contents \u00b6 See workspace . ERC metadata \u00b6 Schema compliant information about the ERC, its contents and creators. Examine \u00b6 One of the major constituents of ERC interaction. It comprises Check , Inspect , Manipulate and Substitute . To examine an ERC means to explore its contents in depth, i.e. check the reproduced version, inspect text, code and data, manipulate interactive elements, as well as exchange input data. Inner container \u00b6 See runtime container Inspect \u00b6 A subconstituent of Examine . Inspection includes looking at all the contents of an ERC, such as code or data files, and metadata documents. A user conducting inspection evaluates the meaning of the ERC\u2019s artifacts. Dependency \u00b6 If software/ library X is required by software/tool Y to function properly, then Y has the dependency X or X is a dependency of Y . Collecting all the right dependencies, which work with each other, can be a hard problem, see Dependency hell . Dependencies can be packages of the same language (like R extension package requiring another R extension package) or system dependencies (like a Python library from PyPI requiring a specific library available via the operating system package manager ). Display file \u00b6 The file in the container that a reader software uses as the first display to a user to read text and explore graphics. The entry point for examination . Manipulate \u00b6 A subconstituent of Examine . A manipulation comprises interactive changing of selected, pre-defined parameters that influence the computation packaged in an ERC. For example, the number of layers in a neural network, the size/selection method of the training dataset in supervised machine learning, or the variogram model of geostatistical kriging. These parameters are defined via UI bindings . OAIS \u00b6 The Open Archival Information System and its reference model . Outer container \u00b6 Term used to distinguish the \u201couter\u201d Bag from the embedded runtime container . Reproducible, Reproducibility, Replication \u00b6 See section 2.1 \u201cDefinition of Reproducibility\u201d . Runtime container \u00b6 A Linux container , more specifically a Docker container , which is a special format to package an application and its dependencies . For usage in this specification, the runtime container can be used to provide the computational environment needed for execution of an ERC\u2019s workflow. It is a transferable snapshot of the authors computer, but also documents the software used by an ERC. Runtime manifest \u00b6 A formal description or recipe for a runtime container , more specifically a Dockerfile . Docker can build images automatically by reading the instructions from a Dockerfile. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. source Substitute \u00b6 A subconstituent of Examine . During a substitution, compatible parts of an ERC are exchanged, e.g. similar data sets for a given analysis, or exchanging an analysis script. A substitution process usually creates a new ERC based on two input ERCs: the base ERC and the overlay ERC . One or several data or code files from the overlay ERC replace corresponding files in the base ERC , to create a new ERC. UI bindings \u00b6 Formal descriptions of parameters and interactions used during Examine . The UI bindings are included in the configuration file and may be created manually or with help of a user-friendly wizard. Workspace \u00b6 The files created by the author of the original analysis. The workspace is packaged together with ERC metadata, runtime container and runtime manifest in the payload directory of the outer container .","title":"Glossary"},{"location":"glossary/#glossary","text":"","title":"Glossary"},{"location":"glossary/#computational-analysis","text":"A scientific workflow that is to be preserved in an ERC. It conducts a number of operations on data and generates an output (text, numbers, plots).","title":"(Computational) Analysis"},{"location":"glossary/#bag","text":"See BagIt specification . A set of opaque data contained within the structure defined by this specification.","title":"Bag"},{"location":"glossary/#compendium-contents","text":"See ERC contents","title":"Compendium contents"},{"location":"glossary/#container","text":"A receptacle holding a collection of things (\u201cpayload\u201d or \u201ccontents\u201d). In the context of this specification, two containers are distinguished: runtime container and outer container .","title":"Container"},{"location":"glossary/#check","text":"A subconstituent of Examine . Checking an ERC is a syntactical validation, which may be largely automated by a software tool reporting the check result and potential errors. A check comprises (a) the validation of a concrete ERC against the ERC specification, e.g. are required files and metadata fields present, and (b) an execution of the contained analysis. The execution includes a comparison of the result files in the just executed inner container with the result stored in the outer container.","title":"Check"},{"location":"glossary/#create","text":"One of the major constituents of ERC interaction. The user can create an ERC by following the technical instructions included in the Specification (ERC Spec) or use the o2r reproducibility service. For more information, see erc-spec/user-guide/creation/ .","title":"Create"},{"location":"glossary/#discover","text":"One of the major constituents of ERC interaction. Discovery comprises the findability of the ERC as well as the exploration of its features, e.g. time and space driven search operations.","title":"Discover"},{"location":"glossary/#erc","text":"Executable Research Compendium, see article .","title":"ERC"},{"location":"glossary/#erc-contents","text":"See workspace .","title":"ERC contents"},{"location":"glossary/#erc-metadata","text":"Schema compliant information about the ERC, its contents and creators.","title":"ERC metadata"},{"location":"glossary/#examine","text":"One of the major constituents of ERC interaction. It comprises Check , Inspect , Manipulate and Substitute . To examine an ERC means to explore its contents in depth, i.e. check the reproduced version, inspect text, code and data, manipulate interactive elements, as well as exchange input data.","title":"Examine"},{"location":"glossary/#inner-container","text":"See runtime container","title":"Inner container"},{"location":"glossary/#inspect","text":"A subconstituent of Examine . Inspection includes looking at all the contents of an ERC, such as code or data files, and metadata documents. A user conducting inspection evaluates the meaning of the ERC\u2019s artifacts.","title":"Inspect"},{"location":"glossary/#dependency","text":"If software/ library X is required by software/tool Y to function properly, then Y has the dependency X or X is a dependency of Y . Collecting all the right dependencies, which work with each other, can be a hard problem, see Dependency hell . Dependencies can be packages of the same language (like R extension package requiring another R extension package) or system dependencies (like a Python library from PyPI requiring a specific library available via the operating system package manager ).","title":"Dependency"},{"location":"glossary/#display-file","text":"The file in the container that a reader software uses as the first display to a user to read text and explore graphics. The entry point for examination .","title":"Display file"},{"location":"glossary/#manipulate","text":"A subconstituent of Examine . A manipulation comprises interactive changing of selected, pre-defined parameters that influence the computation packaged in an ERC. For example, the number of layers in a neural network, the size/selection method of the training dataset in supervised machine learning, or the variogram model of geostatistical kriging. These parameters are defined via UI bindings .","title":"Manipulate"},{"location":"glossary/#oais","text":"The Open Archival Information System and its reference model .","title":"OAIS"},{"location":"glossary/#outer-container","text":"Term used to distinguish the \u201couter\u201d Bag from the embedded runtime container .","title":"Outer container"},{"location":"glossary/#reproducible-reproducibility-replication","text":"See section 2.1 \u201cDefinition of Reproducibility\u201d .","title":"Reproducible, Reproducibility, Replication"},{"location":"glossary/#runtime-container","text":"A Linux container , more specifically a Docker container , which is a special format to package an application and its dependencies . For usage in this specification, the runtime container can be used to provide the computational environment needed for execution of an ERC\u2019s workflow. It is a transferable snapshot of the authors computer, but also documents the software used by an ERC.","title":"Runtime container"},{"location":"glossary/#runtime-manifest","text":"A formal description or recipe for a runtime container , more specifically a Dockerfile . Docker can build images automatically by reading the instructions from a Dockerfile. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. source","title":"Runtime manifest"},{"location":"glossary/#substitute","text":"A subconstituent of Examine . During a substitution, compatible parts of an ERC are exchanged, e.g. similar data sets for a given analysis, or exchanging an analysis script. A substitution process usually creates a new ERC based on two input ERCs: the base ERC and the overlay ERC . One or several data or code files from the overlay ERC replace corresponding files in the base ERC , to create a new ERC.","title":"Substitute"},{"location":"glossary/#ui-bindings","text":"Formal descriptions of parameters and interactions used during Examine . The UI bindings are included in the configuration file and may be created manually or with help of a user-friendly wizard.","title":"UI bindings"},{"location":"glossary/#workspace","text":"The files created by the author of the original analysis. The workspace is packaged together with ERC metadata, runtime container and runtime manifest in the payload directory of the outer container .","title":"Workspace"},{"location":"pdf_cover/","text":"Executable Research Compendium Specification \u00b6 This is the technical specification of the Executable Research Compendium (ERC) in PDF format. The normative version is available in Markdown format in the online repository: https://github.com/o2r-project/erc-spec/ . This specification and guides are developed by the members of the DFG-funded project Opening Reproducible Research License \u00b6 The o2r Executable Research Compendium specification is licensed under Creative Commons CC0 1.0 Universal License , see file LICENSE . To the extent possible under law, the people who associated CC0 with this work have waived all copyright and related or neighboring rights to this work. This work is published from: Germany.","title":"Executable Research Compendium Specification"},{"location":"pdf_cover/#executable-research-compendium-specification","text":"This is the technical specification of the Executable Research Compendium (ERC) in PDF format. The normative version is available in Markdown format in the online repository: https://github.com/o2r-project/erc-spec/ . This specification and guides are developed by the members of the DFG-funded project Opening Reproducible Research","title":"Executable Research Compendium Specification"},{"location":"pdf_cover/#license","text":"The o2r Executable Research Compendium specification is licensed under Creative Commons CC0 1.0 Universal License , see file LICENSE . To the extent possible under law, the people who associated CC0 with this work have waived all copyright and related or neighboring rights to this work. This work is published from: Germany.","title":"License"},{"location":"support/","text":"Support \u00b6 If you have questions about the ERC specification and its usage which are not answered by the user and developer guides , feel free to contact us using the options below. Email \u00b6 daniel.nuest@uni-muenster.de Discussion forum \u00b6 var disqus_config = function () { this.page.url = \"https://o2r.info/erc-spec/support\"; this.page.identifier = \"erc-spec-support\"; }; (function() { var d = document, s = d.createElement('script'); s.src = '//o2r-blog.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus.","title":"Support"},{"location":"support/#support","text":"If you have questions about the ERC specification and its usage which are not answered by the user and developer guides , feel free to contact us using the options below.","title":"Support"},{"location":"support/#email","text":"daniel.nuest@uni-muenster.de","title":"Email"},{"location":"support/#discussion-forum","text":"var disqus_config = function () { this.page.url = \"https://o2r.info/erc-spec/support\"; this.page.identifier = \"erc-spec-support\"; }; (function() { var d = document, s = d.createElement('script'); s.src = '//o2r-blog.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus.","title":"Discussion forum"},{"location":"dev-guide/","text":"ERC developer guide \u00b6 An introduction to the ERC rational and the technology choices made within the project Opening Reproducible Research (o2r), and ideas for downstream products based on ERCs. This documents is targeted at developers who wish to create tools for creating, validating, and consuming ERC or who wonder about why specific tools or approaches were taken in designing the ERC specification. More information about the software developed by o2r: o2r Web API specification o2r Architecture documentation o2r Reference Implementation Note This guide is a draft. If you have comments or suggestions please file them in the issue tracker . If you have explicit changes please fork the git repo and submit a pull request. Convention over configuration and DevOps \u00b6 The ERC specification is inspired by two approaches to improve development and operation of software. First, \u201cconvention over configuration\u201d , e.g. as practiced in the Java build tool Maven . We want to create a directory structure with default file names and sensible defaults. This way a typical research workspace should require only minimal configuration in 80% of the cases, while allowing to override each of the settings if need be and providing full customizability in the remaining 20%. For example, the main command to compile the text manuscript in a compendium could be knitr::knit(\"<*>.Rmd\") , with <*> being replaced by name of the first RMarkdown file. However, if a user wants to use rmarkdown::render(..) on a file named publication.md , then the default behaviour can be overwritten. Second, \u201cDevOps\u201d , see Wikipedia or Boettiger . All processing and configuration shall be scripted, no \u201cclick\u201d interaction required. Related initiatives, specifications, \u2026 \u00b6 ActivePapers eLife Reproducible Document Stack and the dar format Whole Tale , see its serialization format REANA by CERN Reasoning and decisions \u00b6 What is the life span of an ERC? \u00b6 Short answer: 10 years. Software that is \u201carchived\u201d is not intended to be \u201cused\u201d anymore. In 50 or 60 years time we cannot imagine how software or computers will look like. Science historians might still find a lot of valuable information in ERC, though. We also think it is reasonable to assume that an organisation (e.g. a journal) which bases their workflow on ERCs is able to support time ranges going well beyond 10 years. The ERC focusses on providing a usable environment for research workflows in the context of scholarly publishing (reviews etc.). Two aspects have an impact on the time frame we target for ERCs: (a) the nature of financing science and (b) the requirement to actually have a piece of code and data that is still interesting to use. Financing of scientific research is normally based on projects with a specific life span. We follow common guidelines for publishing scientific data , which require projects to ensure data availability for 10 years. Although much of the software we use today (like R) is actually quite \u201cold\u201d, we do not expect pieces of software that are relevant and useful to disappear for many years and only be preserved in ERCs. So, valuable software will exists and be maintained outside of ERCs. Specific software might only exist in ERCs and can be thoroughly inspected forever, but potentially not be executed anymore after a decade. We acknowledge a half life of computations and \u201cexact repeatability\u201d, but the medium term reproducibility of ERC are already a huge improvement over the current state at the example of research data. The situation for research data might have improved in the last years, but the situation for code is mostly unknown and might be even worse. Notes and decisions to elaborate on\u2026 \u00b6 research workflows with environmental or generated data can be \u201cborn digital \u201d from beginning and stay that way to the end (sensors, data storage, data analysis, presentation, review, publication) researchers do their thing and need independence/flexibility, so post-hoc creation will probably be most common and ERC must have low to no impact on workflow data storage, citation (for giving credit) and preservation is solved (repos, DOIs, bitstream preservation in archives) packaging methods/methodology for software is solved (R packages, Python packages, \u2026) software preservation is not solved (methods are there, like migration, emulation, but complexity is too high to do this at high granularity) reproducible paper is somewhat solved (literate programming, R package dependency handling solutions, ..) computational RR requires sandboxing (to make sure everything is there, but also for security) a service is needed to create ERC for researchers and executes them in a controlled environment Why nested containers? \u00b6 A user shall have access to the files without starting the runtime container. Therefore we have at least two items, so we have a bundle and need an outer container. As a bonus, the outer container can immediately be used to make an ERC conform to specific use cases, such as long term archival. Also the chosen outer container solution (zip, tarball) is much older and common than the inner container standard, and thus more likely to exist longer. \u201cWhat\u2019s oldest lasts longest.\u201d source Why your own configuration file? \u00b6 Because it gives control and freedom. The ERC has more than one building block, and if we want to make any of them configurable, we need a place to get users as well as tools started, an \u201centrypoint\u201d. Why not use container labels? The alternative of putting everything into the container itself (e.g. using image labels for metadata and configuration) can be evaluated in the future. The idea is interesting as labels can be named/grouped with \u201cnamespaces\u201d and could contain more complex information than currently prevalent. See also #19 . Why BagIt? \u00b6 BagIt is something that preservation experts understand and covers what they care about (bitstream preservation), so it seemed a good fit in the first project vision. BagIt originally was the required packaging for uploading of data, but that has changed. Users upload their data and analysis, and then execute the analysis to ensure the output matches what they created themselves. This is more important than correct bits, which become relevant again after creation of an ERC when it is stored and a bag is created. What about the limitations of containers? \u00b6 We are aware of the limitations that containers have. Most importantly the operating system and the kernel are not included. This results in smaller container size and better performance (e.g. quicker start because no \u201cboot\u201d) and also has security advantages. However, it also means that the encapsulated runtime environment in ERCs is not \u201call the way down\u201d. It must be noted that of course changes in the operating system and it\u2019s kernel may break a workflow encapsulated in a container. Let\u2019s consider the Linux Kernel . Those breaking changes are very rare . Let\u2019s consider Docker . Docker containers have by now been standardised by the OCI and ERCs should rely on the open standard in the future (contributions welcome). The maintenance lifecycle and compatibility matrix of Docker do not imply they are suitable for the targeted time frame for ERCs. However, all these projects are Open Source software or documentation, and a long term provider for ERC (i.e. not a small research project) can handle these limitations in different ways, for example organisationally with long term maintenance contracts or technically as outlined in the o2r architecture in the production architecture sketch . These include specialised hardware and operating system specifics. Why Docker? \u00b6 (Docker) containers provide an encapsulation mechanism to package all dependencies of an analysis Docker now basically is OCI, so switching to other tools should be possible. during container execution, and substitution, the build in copy-on-write storage only creates copy of files that are changed within the container, thus saving storage capacity volume mounts allow easy substitution of input data and configurations of analysis Why not Singularity? \u00b6 Singularity is an open source containerization solution. It might very well be a better choice for reproducible research in the future as it stems from the scientific community (HPC), cf. also C4RR workshop 2017 . At the point of starting the specification, Docker was more widespread and implementations more readily available. Furthermore the origin of Singularity, high performance computing, is out of scope of ERC. We do not see an issue in not using Singulary. Most importantly, the concepts runtime manifest and runtime image are abstract, i.e. independent of Docker and the concrete container tool choice could be made flexible in future versions of the specification. Singularity can import Docker images and as such make a transition possible, or even let an implementation use Singularity without touch the specification. Why R Markdown as the main file? \u00b6 First of all, there is no alternative to literate programming . It is the format in the R community, used more and more for in-line documentation , vignettes , blogs , software websites , books and even scientific articles in multiple output formats via Pandoc and potentially Pandoc Scholar . The uptake in the community alone warrants its usage. It also supports other languages than just R and is a good basis for agile production of open science literature. Futhermore, it is a plain text format with comparatively simple syntax, so it facilitates long-term interpretability. The structured YAML header also does not hurt for archivability. Why HTML outputs? \u00b6 HTML is text-based and therefore allows automatically comparing and creating difference sets with typical \u201cdiffing\u201d tools. This is a crucial advantage over PDFs and outweighs the benefits of PDF/A. Why not just use plain R? \u00b6 It would be possible to rely solely on R for replication. For example, the runtime manifest could be a codemeta document, and the runtime environment is created based on it outside of the ERC when needed, for example by installing R in the required version. Additionally a package for preserving a state of dependencies could be used, e.g. packrat . This solution is potentially less storage intensive, because containers replicate an R installation each time. Smaller storages might also ease collaboration. However, none of these solutions touches the underlying system libraries. The complexity of preserving the runtime environment is transferred from the packaging stage to the unpackaging stage, which is unfavourable because that packaging state \u201ceverything works\u201d, so better control is ensured at that time. The burden in a plain R solution shifts from authoring to preservation. Even though shipping system binaries within packages is possible (if not common), some packages do use system libraries which are not preserved in a plain R approach. Adjusting such packages is not an option. Furthermore, none of the solutions for reproducibility are part of \u201ccore R\u201d, even if they are trustworthy (e.g. MRAN). CRAN does not support installing specific package versions. That is why using an abstraction layer outside of R is preferable. What if licensing information is not detailed enough? \u00b6 Without proper license credits, the contents of an ERC would be useless based on today\u2019s copyright laws. Therefore we rather have the extra work for authors to define a couple of licenses than to create something that is unusable by others. One of the biggest issues is the scope of licenses , namely what to do about having multiple pieces of code, text, or data with different licenses. Ideas/Notes The erc.yml could also hold more complex license metadata, for specific directories or files. Probably this is better solved in specialised formats, though. Example using specific licenses --- id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec spec_version: 1 licenses: code: others_lib.bin: MIT my_code.c: GPL-3.0 data: facts.csv: ODbL-1.0 text: README.md: CC0-1.0 paper.Rmd: CC-BY-4.0 metadata: CC0-1.0 It could even be possible to assign one license to a directory and override that assignment for a single file within that directory, or use globs or regular expressions. Why (not) put \u201cX\u201d into the ERC configuration file? \u00b6 identifier makes it easier to track across platforms is harder for manual creation kernel would have to use our own label within image metadata os and architecture are already clearly defined im image spec can be extracted from a plain text file in the image tarball, so implementations can get them (quickly) before loading an image (a potentially costly operation) Docker version is already clearly defined in image spec Why is validation happening outside the container and not in the container? \u00b6 better user experience (otherwise all info must be transported via stdout) to be sure nothing is manipulated within the validation script Why is the data not in the image (inner container) but in the outer container? \u00b6 better accessible in the long term no data duplication ERC completeness score \u00b6 While the ERC is intended to be simple enough to be created manually, the clear requirements on it\u2019s contents also serve a semi-automatic creation. For example, a user can upload a workspace with data files, and R Markdown document, and an HTML rendering of the document to an online platform, where the runtime manifest and image are automatically created. In such a case, metadata would still be added manually. To encourage users, especially during the manual steps of the creation process, to provide valuable input a completeness score can be useful. Comparable to profile editors on social network sites, a percentage based score can be used to highlight content or aspects going beyond the mandatory requirements. Implementing platforms may create their own rules, for example which of the optional metadata elements contribute towards reaching a full score. Thinking beyond merely the metadata, the score could also cover the runtime manifest (e.g. does it follow common practices, include relevant independent metadata, uses explicit versioning for dependency installation), contained code (e.g. automatic checks against code formatting guidelines, syntactical errors), and contained data (e.g. are open file formats used, maybe rewarding CSV over Shapefiles). A completeness score can be seen as a downstream product based on the ERC. It is unlikely this ever makes it into an ERC specification, but it can be a crucial means towards acceptance, adoption, and success of ERCs.","title":"Developer guide"},{"location":"dev-guide/#erc-developer-guide","text":"An introduction to the ERC rational and the technology choices made within the project Opening Reproducible Research (o2r), and ideas for downstream products based on ERCs. This documents is targeted at developers who wish to create tools for creating, validating, and consuming ERC or who wonder about why specific tools or approaches were taken in designing the ERC specification. More information about the software developed by o2r: o2r Web API specification o2r Architecture documentation o2r Reference Implementation Note This guide is a draft. If you have comments or suggestions please file them in the issue tracker . If you have explicit changes please fork the git repo and submit a pull request.","title":"ERC developer guide"},{"location":"dev-guide/#convention-over-configuration-and-devops","text":"The ERC specification is inspired by two approaches to improve development and operation of software. First, \u201cconvention over configuration\u201d , e.g. as practiced in the Java build tool Maven . We want to create a directory structure with default file names and sensible defaults. This way a typical research workspace should require only minimal configuration in 80% of the cases, while allowing to override each of the settings if need be and providing full customizability in the remaining 20%. For example, the main command to compile the text manuscript in a compendium could be knitr::knit(\"<*>.Rmd\") , with <*> being replaced by name of the first RMarkdown file. However, if a user wants to use rmarkdown::render(..) on a file named publication.md , then the default behaviour can be overwritten. Second, \u201cDevOps\u201d , see Wikipedia or Boettiger . All processing and configuration shall be scripted, no \u201cclick\u201d interaction required.","title":"Convention over configuration and DevOps"},{"location":"dev-guide/#related-initiatives-specifications","text":"ActivePapers eLife Reproducible Document Stack and the dar format Whole Tale , see its serialization format REANA by CERN","title":"Related initiatives, specifications, ..."},{"location":"dev-guide/#reasoning-and-decisions","text":"","title":"Reasoning and decisions"},{"location":"dev-guide/#what-is-the-life-span-of-an-erc","text":"Short answer: 10 years. Software that is \u201carchived\u201d is not intended to be \u201cused\u201d anymore. In 50 or 60 years time we cannot imagine how software or computers will look like. Science historians might still find a lot of valuable information in ERC, though. We also think it is reasonable to assume that an organisation (e.g. a journal) which bases their workflow on ERCs is able to support time ranges going well beyond 10 years. The ERC focusses on providing a usable environment for research workflows in the context of scholarly publishing (reviews etc.). Two aspects have an impact on the time frame we target for ERCs: (a) the nature of financing science and (b) the requirement to actually have a piece of code and data that is still interesting to use. Financing of scientific research is normally based on projects with a specific life span. We follow common guidelines for publishing scientific data , which require projects to ensure data availability for 10 years. Although much of the software we use today (like R) is actually quite \u201cold\u201d, we do not expect pieces of software that are relevant and useful to disappear for many years and only be preserved in ERCs. So, valuable software will exists and be maintained outside of ERCs. Specific software might only exist in ERCs and can be thoroughly inspected forever, but potentially not be executed anymore after a decade. We acknowledge a half life of computations and \u201cexact repeatability\u201d, but the medium term reproducibility of ERC are already a huge improvement over the current state at the example of research data. The situation for research data might have improved in the last years, but the situation for code is mostly unknown and might be even worse.","title":"What is the life span of an ERC?"},{"location":"dev-guide/#notes-and-decisions-to-elaborate-on","text":"research workflows with environmental or generated data can be \u201cborn digital \u201d from beginning and stay that way to the end (sensors, data storage, data analysis, presentation, review, publication) researchers do their thing and need independence/flexibility, so post-hoc creation will probably be most common and ERC must have low to no impact on workflow data storage, citation (for giving credit) and preservation is solved (repos, DOIs, bitstream preservation in archives) packaging methods/methodology for software is solved (R packages, Python packages, \u2026) software preservation is not solved (methods are there, like migration, emulation, but complexity is too high to do this at high granularity) reproducible paper is somewhat solved (literate programming, R package dependency handling solutions, ..) computational RR requires sandboxing (to make sure everything is there, but also for security) a service is needed to create ERC for researchers and executes them in a controlled environment","title":"Notes and decisions to elaborate on..."},{"location":"dev-guide/#why-nested-containers","text":"A user shall have access to the files without starting the runtime container. Therefore we have at least two items, so we have a bundle and need an outer container. As a bonus, the outer container can immediately be used to make an ERC conform to specific use cases, such as long term archival. Also the chosen outer container solution (zip, tarball) is much older and common than the inner container standard, and thus more likely to exist longer. \u201cWhat\u2019s oldest lasts longest.\u201d source","title":"Why nested containers?"},{"location":"dev-guide/#why-your-own-configuration-file","text":"Because it gives control and freedom. The ERC has more than one building block, and if we want to make any of them configurable, we need a place to get users as well as tools started, an \u201centrypoint\u201d. Why not use container labels? The alternative of putting everything into the container itself (e.g. using image labels for metadata and configuration) can be evaluated in the future. The idea is interesting as labels can be named/grouped with \u201cnamespaces\u201d and could contain more complex information than currently prevalent. See also #19 .","title":"Why your own configuration file?"},{"location":"dev-guide/#why-bagit","text":"BagIt is something that preservation experts understand and covers what they care about (bitstream preservation), so it seemed a good fit in the first project vision. BagIt originally was the required packaging for uploading of data, but that has changed. Users upload their data and analysis, and then execute the analysis to ensure the output matches what they created themselves. This is more important than correct bits, which become relevant again after creation of an ERC when it is stored and a bag is created.","title":"Why BagIt?"},{"location":"dev-guide/#what-about-the-limitations-of-containers","text":"We are aware of the limitations that containers have. Most importantly the operating system and the kernel are not included. This results in smaller container size and better performance (e.g. quicker start because no \u201cboot\u201d) and also has security advantages. However, it also means that the encapsulated runtime environment in ERCs is not \u201call the way down\u201d. It must be noted that of course changes in the operating system and it\u2019s kernel may break a workflow encapsulated in a container. Let\u2019s consider the Linux Kernel . Those breaking changes are very rare . Let\u2019s consider Docker . Docker containers have by now been standardised by the OCI and ERCs should rely on the open standard in the future (contributions welcome). The maintenance lifecycle and compatibility matrix of Docker do not imply they are suitable for the targeted time frame for ERCs. However, all these projects are Open Source software or documentation, and a long term provider for ERC (i.e. not a small research project) can handle these limitations in different ways, for example organisationally with long term maintenance contracts or technically as outlined in the o2r architecture in the production architecture sketch . These include specialised hardware and operating system specifics.","title":"What about the limitations of containers?"},{"location":"dev-guide/#why-docker","text":"(Docker) containers provide an encapsulation mechanism to package all dependencies of an analysis Docker now basically is OCI, so switching to other tools should be possible. during container execution, and substitution, the build in copy-on-write storage only creates copy of files that are changed within the container, thus saving storage capacity volume mounts allow easy substitution of input data and configurations of analysis","title":"Why Docker?"},{"location":"dev-guide/#why-not-singularity","text":"Singularity is an open source containerization solution. It might very well be a better choice for reproducible research in the future as it stems from the scientific community (HPC), cf. also C4RR workshop 2017 . At the point of starting the specification, Docker was more widespread and implementations more readily available. Furthermore the origin of Singularity, high performance computing, is out of scope of ERC. We do not see an issue in not using Singulary. Most importantly, the concepts runtime manifest and runtime image are abstract, i.e. independent of Docker and the concrete container tool choice could be made flexible in future versions of the specification. Singularity can import Docker images and as such make a transition possible, or even let an implementation use Singularity without touch the specification.","title":"Why not Singularity?"},{"location":"dev-guide/#why-r-markdown-as-the-main-file","text":"First of all, there is no alternative to literate programming . It is the format in the R community, used more and more for in-line documentation , vignettes , blogs , software websites , books and even scientific articles in multiple output formats via Pandoc and potentially Pandoc Scholar . The uptake in the community alone warrants its usage. It also supports other languages than just R and is a good basis for agile production of open science literature. Futhermore, it is a plain text format with comparatively simple syntax, so it facilitates long-term interpretability. The structured YAML header also does not hurt for archivability.","title":"Why R Markdown as the main file?"},{"location":"dev-guide/#why-html-outputs","text":"HTML is text-based and therefore allows automatically comparing and creating difference sets with typical \u201cdiffing\u201d tools. This is a crucial advantage over PDFs and outweighs the benefits of PDF/A.","title":"Why HTML outputs?"},{"location":"dev-guide/#why-not-just-use-plain-r","text":"It would be possible to rely solely on R for replication. For example, the runtime manifest could be a codemeta document, and the runtime environment is created based on it outside of the ERC when needed, for example by installing R in the required version. Additionally a package for preserving a state of dependencies could be used, e.g. packrat . This solution is potentially less storage intensive, because containers replicate an R installation each time. Smaller storages might also ease collaboration. However, none of these solutions touches the underlying system libraries. The complexity of preserving the runtime environment is transferred from the packaging stage to the unpackaging stage, which is unfavourable because that packaging state \u201ceverything works\u201d, so better control is ensured at that time. The burden in a plain R solution shifts from authoring to preservation. Even though shipping system binaries within packages is possible (if not common), some packages do use system libraries which are not preserved in a plain R approach. Adjusting such packages is not an option. Furthermore, none of the solutions for reproducibility are part of \u201ccore R\u201d, even if they are trustworthy (e.g. MRAN). CRAN does not support installing specific package versions. That is why using an abstraction layer outside of R is preferable.","title":"Why not just use plain R?"},{"location":"dev-guide/#what-if-licensing-information-is-not-detailed-enough","text":"Without proper license credits, the contents of an ERC would be useless based on today\u2019s copyright laws. Therefore we rather have the extra work for authors to define a couple of licenses than to create something that is unusable by others. One of the biggest issues is the scope of licenses , namely what to do about having multiple pieces of code, text, or data with different licenses. Ideas/Notes The erc.yml could also hold more complex license metadata, for specific directories or files. Probably this is better solved in specialised formats, though. Example using specific licenses --- id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec spec_version: 1 licenses: code: others_lib.bin: MIT my_code.c: GPL-3.0 data: facts.csv: ODbL-1.0 text: README.md: CC0-1.0 paper.Rmd: CC-BY-4.0 metadata: CC0-1.0 It could even be possible to assign one license to a directory and override that assignment for a single file within that directory, or use globs or regular expressions.","title":"What if licensing information is not detailed enough?"},{"location":"dev-guide/#why-not-put-x-into-the-erc-configuration-file","text":"identifier makes it easier to track across platforms is harder for manual creation kernel would have to use our own label within image metadata os and architecture are already clearly defined im image spec can be extracted from a plain text file in the image tarball, so implementations can get them (quickly) before loading an image (a potentially costly operation) Docker version is already clearly defined in image spec","title":"Why (not) put \"X\" into the ERC configuration file?"},{"location":"dev-guide/#why-is-validation-happening-outside-the-container-and-not-in-the-container","text":"better user experience (otherwise all info must be transported via stdout) to be sure nothing is manipulated within the validation script","title":"Why is validation happening outside the container and not in the container?"},{"location":"dev-guide/#why-is-the-data-not-in-the-image-inner-container-but-in-the-outer-container","text":"better accessible in the long term no data duplication","title":"Why is the data not in the image (inner container) but in the outer container?"},{"location":"dev-guide/#erc-completeness-score","text":"While the ERC is intended to be simple enough to be created manually, the clear requirements on it\u2019s contents also serve a semi-automatic creation. For example, a user can upload a workspace with data files, and R Markdown document, and an HTML rendering of the document to an online platform, where the runtime manifest and image are automatically created. In such a case, metadata would still be added manually. To encourage users, especially during the manual steps of the creation process, to provide valuable input a completeness score can be useful. Comparable to profile editors on social network sites, a percentage based score can be used to highlight content or aspects going beyond the mandatory requirements. Implementing platforms may create their own rules, for example which of the optional metadata elements contribute towards reaching a full score. Thinking beyond merely the metadata, the score could also cover the runtime manifest (e.g. does it follow common practices, include relevant independent metadata, uses explicit versioning for dependency installation), contained code (e.g. automatic checks against code formatting guidelines, syntactical errors), and contained data (e.g. are open file formats used, maybe rewarding CSV over Shapefiles). A completeness score can be seen as a downstream product based on the ERC. It is unlikely this ever makes it into an ERC specification, but it can be a crucial means towards acceptance, adoption, and success of ERCs.","title":"ERC completeness score"},{"location":"spec/","text":"\\newpage ERC specification \u00b6 An Executable Research Compendium (ERC) is a packaging convention for computational research. It provides a well-defined structure for data, code, text, documentation, and user interface controls for a piece of research and is suitable for long-term archival. As such it can also be perceived as a digital object or asset. Note This is a draft specification. If you have comments or suggestions please file them in the issue tracker . If you have explicit changes please fork the git repo and submit a pull request. Preface \u00b6 Version \u00b6 Specification version: 1 Warning This version is under development ! Notational conventions \u00b6 The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d are to be interpreted as described in RFC 2119 . The key words \u201cunspecified\u201d, \u201cundefined\u201d, and \u201cimplementation-defined\u201d are to be interpreted as described in the rationale for the C99 standard . Purpose, target audience, and context \u00b6 This specification defines a structure to transport and execute a computational scientific analysis (cf. computational science ). It carries technical and conceptual details on how to implement tools to enhance reproducibility and is most suitable for developers . Authors may feel more comfortable with the user guides . These analyses typically comprise a digital workspace on a researcher\u2019s computer, which contains data ( born digital , simulated, or other), code , third party software or libraries, and outputs of research such as digital plots or data. Code and libraries are required in executable form to re-do a specific analysis or workflow. Research is only put into a context by a text , e.g. a research paper, which is published in scholarly communication . The text comes in two forms: one that is machine readable, and another one that is suitable for being viewed by humans. The latter is derived, or \u201crendered\u201d, from the former. The viewing experience can be static, textual, visual, or interactive. Putting all of these elements in a self-contained bundle allows examining, reproducing, transferring, archiving, and formally validating computational research results in a time frame for peer review and collaboration. The ERC specification defines metadata and file structures to support these actions. Major constituents \u00b6 Three major constituents group possible user interactions with ERC. Create Creation is transforming a workspace with data, code and text into an ERC. Examine Examination is evaluating ERC at different levels, from inspecting contents to creating derived analyses. Discover Discovery is searching for content powered by ERC properties, such as text, content metadata, code metadata et cetera. Design principles \u00b6 Simplicity This specification should not re-do something which already exists (if it is an open specification or tool). The risk of scattering information is mitigated by clear documentation. It must be possible to create a valid and working ERC manually , while supporting tools should be able to cover typical use cases with minimal required input by a creating user. Nested containers We acknowledge well defined standards for packaging a set of files, and different approaches to create an executable code package. Therefore an ERC comprises one or more containers but is itself subject to being put into a container . We distinguish these containers into the inner or \u201cruntime\u201d container and the outer container, which is used for transfer of complete ERC and not content-aware validation. Transparency, Stability, and Openness Plain text files usable by both humans and computers are the backbone to make sure ERCs are acceptable by users from all scientific domains, are understandable today and tomorrow, and are easy to extend. The ERC contains everything needed to execute a workflow. How to use an ERC \u00b6 The steps to (re-)run the analysis contained in an ERC as part of an examination are as follows: (if compressed first extract then) unpack the ERC\u2019s outer container execute the runtime container compare the output files contained in the outer container with the output files just created by the runtime container This way an ERC allows computational reproducibility based on the original code and data. Three questions \u00b6 [Section inspired by REANA\u2019s \u201cFour Questions\u201d ] The ERC helps to make research papers more transparent an reusable by giving minimal structure for contents and context. They help to answer the \u201cThree Questions\u201d both for users, but more importantly for tools and services built around them. What is your result? file I should look at to see the description and visualisations the \u201cdisplay file\u201d shown by applications based on ERC What is your workflow? file I should look at as a reader when I want to understand your code/analysis/workflow, the steps you took the \u201cmain file\u201d used by applications based on ERC for creating ERCs and executing them, which means running the analysis and creating the result What is your environment? operating system you used software you used (libraries, your own scripts, \u2026) can be used by tools to recreate the same environment ERC structure \u00b6 Base directory \u00b6 An ERC MUST has a base directory . All paths within this document are relative to this base directory. The base directory MUST contain an ERC configuration file . Besides the files mentioned in this specification, the base directory MAY contain any other files and directories. Main & display file \u00b6 An ERC MUST have a main file, i.e. the file which contains the text and instructions being the basis for the scientific publication describing the packaged analysis. An ERC MUST have a _display file , i.e. the file which is shown to a user first when she opens an ERC in a supporting platform or tool. Main file and display file MUST NOT be the same file. The main file MUST be executable in the sense that a software reads it as the input of a process to create the display file . The main file \u2018s name SHOULD be main with an appropriate file extension and media type . Note The main file thus follows the literate programming paradigm . Example If the main file is an R Markdown document, then the file extension should be .Rmd and the media type text/markdown . A file main.Rmd will consequently be automatically identified by an implementation as the ERC\u2019s main file . The display file\u2019s name SHOULD be display with an appropriate file extension and media type. Example If the display file is an Hypertext Markup Language (HTML) document, then the file extension should be .htm or .html and the media type text/html . A file display.html will consequently be automatically identified by an implementation as the ERC\u2019s display file . The ERC MAY use an interactive document with interactive figures and control elements for the packaged computations as the display file . The interactive display file MUST have HTML format and SHOULD be valid HTML5 . Example Typical examples for the two core documents are R Markdown with HTML output (i.e. main.Rmd and display.html ), or an R script creating a PNG file (i.e. main.R and display.png ). Nested runtime \u00b6 The embedding of a representation of the original runtime environment, in which the analysis was conducted, is crucial for supporting reproducible computations. Every ERC MUST include two such such representations: an executable runtime image of the original analysis environment for re-running the packaged analysis, and a runtime manifest documenting the image\u2019s contents as a complete, self-consistent recipe of the runtime image\u2019s contents which is a machine-readable format that allows a respective tool to create the runtime image. The image MUST be stored as a file, e.g. a \u201cbinary\u201d or \u201carchive\u201d, in the ERC base directory. The manifest MUST be stored as a text file in the ERC base directory. System environment The nested runtime encapsulates software, files, and configurations up to a specific level of abstraction. It may not include a complete operating system, for example for better performance or security reasons. While this information is included in the nested runtime, it MUST be accessible without executing the runtime. Hard to obtain information SHOULD be replicated in the configuration file. If the nested runtime does not include the operating system, then the configuration file MUST include the following data about the environment used to create the ERC: architecture operating system kernel (if applicable) runtime software version An implementation SHOULD notify the user if the provided system environment is incompatible with the implementations capabilities. Tip A partially incompatible system environment, especially a different kernel version, may still produce the desired result, as breaking changes are very rare. An implementation may utilise semantic versioning to improve its compatibility tests. An incompatible operating system, e.g. linux vs. windows , and architecture, e.g. amd64 or arm/v7 , are likely to fail. ERC configuration file \u00b6 The ERC configuration file is the reproducibility manifest for an ERC. It defines the main entry points for actions performed on an ERC and core metadata elements. Name, format, and encoding \u00b6 The filename MUST be erc.yml and it MUST be located in the base directory. The contents MUST be valid YAML 1.2 . The file MUST be encoded in UTF-8 and MUST NOT contain a byte-order mark (BOM). Basic fields \u00b6 The first document content of this file MUST contain the following string nodes at the root level. spec_version : a text string noting the version of the used ERC specification. The appropriate version for an ERC conforming to this version of the specification is 1 . id : globally unique identifier for a specific ERC. id MUST not be empty and MUST only contain lowercase letters, uppercase letters, digits and single separators. Valid separators are period, underscore, or dash. A name component MUST NOT start or end with a separator. An implementation MAY introduce further restrictions on minimum and maximum length of identifiers. Note While URIs (see rfc3986 ) are very common identifiers, not all systems support them as identifiers. For example they cannot be used for Docker image names. A UUID is a valid id . A regular expression to validate identifiers is /^[^-_.][a-zA-Z0-9._-]+[^-_.]$/ . The main and display file MAY be defined in root-level nodes named main and display respectively. If they are not defined and multiple documents use the name main.[ext] or display.[ext] , an implementation SHOULD use the first file in alphabetical order . Example of ERC configuration file with user-defined main and display files id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec spec_version: 1 main: workflow.Rmd display: paper.html Additionally, related resources such as a related publication can be stated with the relatedIdentifier element field. A related identifier SHOULD be a globally unique persistent identifier and SHOULD be a URI. Author and license metadata \u00b6 The main document MUST include information about the authors. It SHOULD contain this information in a structured way so it can be parsed by tools supporting ERCs. Note An example for structured metadata is markup with author names and affiliations in the header of the main document. The file erc.yml MUST contain a first level node licenses with licensing information for contained artefacts. Each of these artefacts, e.g. code or data, have distinct requirements so it must be possible to apply different licenses. The node licenses MUST have four child nodes: text , data , code , and metadata . Note There is currently no mechanism to define the licenses of all the used libraries and software in a structured format. Manual creation would be tedious. Tools for automatic creation of ERC may add such detailed licensing information and define additional metadata elements. The content of each of these child nodes MUST be a string with one of the following contents: license identifier as defined by the Open Definition Licenses Service name of file with either documentation on licensing or a full license text Example for common licenses id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec spec_version: 1 licenses: code: Apache-2.0 data: ODbL-1.0 text: CC0-1.0 metadata: CC0-1.0 Example for non-standard licenses id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec spec_version: 1 licenses: code: Apache-2.0 data: data-licenses.txt text: \"Creative Commons Attribution 2.0 Generic (CC BY 2.0)\" metadata: \"see metadata license headers\" Runtime manifest and image \u00b6 The ERC uses Docker to define, build, and store the nested runtime environment. Runtime image \u00b6 The runtime environment or image MUST be represented by a Docker image v1.2.0 . Note A concrete implementation of ERC may choose to rely on constructing the runtime environment from the manifest when needed, e.g. for export to a repository, while the ERC is constructed. The base directory MUST contain a tarball , i.e. an archive file, of a Docker image as created be the command docker save , see Docker CLI save command documentation , as defined in version 1.12.x . The image MUST have a tag erc:<erc identifier> , for example erc:b9b0099e-9f8d-4a33-8acf-cb0c062efaec . The image file MAY be compressed. The image archive file name MUST be image with an appropriate file extension, such as .tar , .tar.gz (if a gzip compression is used for the archive ) or .bin , and have an appropriate mime type, e.g. application/vnd.oci.image.layer.tar+gzip . Note Before exporting the Docker image, it should be build from the runtime manifest, including the tag which can be used to identify the image, for example: docker build --tag erc:b9b0099e-9f8d . docker images erc:b9b0099e-9f8d docker save erc:b9b0099e-9f8d > image.tar # save with compression: docker save erc:b9b0099e-9f8d | gzip -c > image.tar.gz Do not use docker export , because it is used to create a snapshot of a container, which must not match the Dockerfile anymore as it may have been manipulated during a run. Runtime manifest \u00b6 The runtime manifest MUST be represented by a valid Dockerfile , see Docker builder reference , as defined in version 1.12.x . The file MUST be named Dockerfile . The Dockerfile MUST contain the build instructions for the runtime environment and MUST have been used to create the image saved to the runtime image using docker build , see Docker CLI build command documentation , as defined in version 1.12.x . The build SHOULD be done with the option --no-cache=true . The Dockerfile MUST NOT use the latest tag in the instruction FROM . Note The \u201clatest\u201d tag is merely a convention to denote the latest available image, so any tag can have undesired results. Nevertheless, using an image tagged \u201clatest\u201d makes it much more likely to change over time. Although there is no guarantee that images tagged differently, e.g. \u201cv1.2.3\u201d might not change as well, using such tags shall be enforced here. The Dockerfile SHOULD contain the label maintainer to provide authorship information. The Dockerfile MUST have an active instruction CMD , or a combination of the instructions ENTRYPOINT and CMD , which executes the packaged analysis. The Dockerfile MUST contain a VOLUME instruction to define the mount point of the ERC base directory within the container. This mount point MUST be /erc and the bind MUST be configured as with read and write access . Implementations SHOULD make sure an execution does not interfere with original uploaded files, but a write access is required to store the created display file outside of the container. The Dockerfile MUST contain a WORKDIR instruction with the value /erc . The Dockerfile SHOULD NOT contain a COPY or ADD command to include data, code or text from the ERC into the image. These commands MAY be used to copy code or libraries which must be available during the image build. The Dockerfile SHOULD NOT contain EXPOSE instructions. System environment \u00b6 The following system environment configurations MUST be provided as nodes under the root-level node execution : (if applicable) kernel , node kernel The following system environment configurations are available within the runtime image metadata and therefore not be replicated in the ERC configuration file. operating system , node os , architecture , node architecture runtime software version , node DockerVersion in output of docker inspect and node docker_version in image metadata JSON file (cf. source code ). Accessing system environment configurations from image metadata in a saved image tarball manifest.json contains a list of the layers and the config as the name of the configuration file. The image metadata is in the <image id>.json file in the root directory of the tarball. The following commands show how to extract the image metadata file from the tarball and print the relevant properties to the console using the JSON cli tool jq . $ tar -xf image.tar --wildcards --no-anchored '[!manifest]*.json' $ cat *.json | jq '.architecture, .os, .docker_version' \"amd64\" \"linux\" \"17.05.0-ce\" Together the image metadata and ERC configuration file provide all properties of the underlying system environment. An implementation SHOULD notify the user if the required system environment is incompatible with the implementation\u2019s capabilities. System environment incompatibilities A partially incompatible system environment, especially a different kernel version, may still produce the desired result, as breaking changes are very rare. An implementation could utilise semantic versioning to improve its compatibility tests. An incompatible operating system, e.g. linux vs. windows , and architecture, e.g. amd64 or arm/v7 , are likely to fail. Example of ERC configuration file with user-defined kernel and excerpt from runtime image metadata ERC configuration file id: b9b0099e-9f8d spec_version: 1 execution: kernel: `4.13.0-32-generic` Image metadata (excerpt) (results of an docker image inspect call): [ { \"Id\" : \"sha256:87362162878143c5e10e94a6ec9b7e925b...\" , \"RepoTags\" : [], \"RepoDigests\" : [], \"Parent\" : \"sha256:a280c143ff833d99274e96bbcfdc86...\" , \"Created\" : \"2018-02-15T15:18:42.623467682Z\" , \"Container\" : \"840b75b48121012a0847bbae148ed96df7...\" , \"ContainerConfig\" : { ... }, \"DockerVersion\" : \"17.05.0-ce\" , \"Author\" : \"<https://o2r.info>\" , \"Config\" : { ... }, \"Architecture\" : \"amd64\" , \"Os\" : \"linux\" , [ ... ] } ] Image metadata (excerpt) (content of <image id>.json from image.tar ): { \"architecture\" : \"amd64\" , \"config\" : { ... , \"Labels\" : { \"maintainer\" : \"o2r\" } }, \"container\" : \"747198d654630530c2a6523abbc19e41d7fcf977833c6854a2a48fb11b8c607c\" , \"container_config\" : { ... }, \"created\" : \"2018-03-08T15:24:20.164740334Z\" , \"docker_version\" : \"17.05.0-ce\" , \"history\" : [ ... ], \"os\" : \"linux\" , \"rootfs\" : { \"type\" : \"layers\" , \"diff_ids\" : [ \"sha256:8568818b1f7f534832b393c531edfcb4a30e7eb40b573e68fdea90358987231f\" , \"sha256:fccd38ea8016190426aa7ef4baba29b0c92de1ee863c3460a34151695fbcba08\" , \"sha256:cf52051fff5bb6430c972ef822d435e9b5242117398b43c6d36f1ed71d978a94\" , \"sha256:5535e4fbfa3ed182d3cc87bfe643f87801c91be6c171535675effb4efc8c1e5a\" , \"sha256:9d55d57e41e02115f48e428a880d88d7bf0af993a232d0c967cc17f012e2e250\" ] } } Execution \u00b6 The configuration file MUST provide enough information to for implementations to create the commands for execution of the runtime image and to provide access to the data and software in the ERC. Implementations MUST support Docker Engine API v1.35 (or compatible). Making data, code, and text available within container \u00b6 The runtime environment image contains all dependencies and libraries needed by the code in an ERC. Especially for large datasets, it in unfeasible to replicate the complete dataset contained within the ERC in the image. For archival, it can also be confusing to replicate code and text, albeit them potentially being relatively small in size, within the container. Therefore a host directory MUST be mounted (also \u201cbind-mounted\u201d) into the compendium container at runtime using a data volume . Example Dockerfile In this example we use a Rocker base image to reproduce computations made in R. FROM rocker/r-ver:3.3.3 RUN apt-get update -qq \\ && apt-get install -y --no-install-recommends \\ ## Packages required by R extension packages # required by rmarkdown: lmodern \\ pandoc \\ # for devtools ( requires git2r, httr ) : libcurl4-openssl-dev \\ libssl-dev \\ git \\ # for udunits: libudunits2-0 \\ libudunits2-dev \\ # required when knitting the document pandoc-citeproc \\ && apt-get clean \\ && rm -rf /var/lib/apt/lists/* # install R extension packages RUN install2.r -r \"http://cran.rstudio.com\" \\ rmarkdown \\ ggplot2 \\ devtools \\ && rm -rf /tmp/downloaded_packages/ /tmp/*.rd # Save installed packages to file RUN dpkg -l > /dpkg-list.txt LABEL maintainer = o2r \\ description = \"This is an ERC image.\" \\ info.o2r.bag.id = \"123456\" VOLUME [ \"/erc\" ] WORKDIR [\"/erc\"] ENTRYPOINT [ \"sh\" , \"-c\" ] CMD [ \"R --vanilla -e \\\"rmarkdown::render(input = '/erc/myPaper.rmd', \\ output_dir = '/erc', output_format = rmarkdown::html_document())\\\"\" ] Main and display file in the container The fixed mount point have the advantage that users and tools can be sure the main and display files are usually available at /erc/main.Rmd and /erc/display.html respectively. Default execution \u00b6 If no execution information is provided, then the implementation MUST assume an unconfigured Docker control flow for loading and executing the nested runtime environment is sufficient. Unconfigured means that NO configuration besides providing a mount of the compendium files (see previous section) MAY be applied. The control statements for Docker executions comprise load , for importing an image from the archive, and run for starting a container of the loaded image. Both control statements MUST be configured by using nodes of the same name under the root-level node execution in the ERC configuration file. Based on the configuration, an implementation can construct the respective runtime software\u2019s commands, i.e. docker load and docker run , using the correct image file name and further parameters (e.g. performance control options). Constructing the execution commands The Docker CLI commands constructed based on configuration file for ERC with ID b9b0099e-9f8d could be as follows. In this case the implementation uses -it to pass stdout streams to the user and adds an identifier for the container using --name . docker load --input image.tar docker run -it --name run_b9b0099e \\ --volume /storage/erc/abc123:/erc \\ erc:b9b0099e-9f8d The output of the container during execution MAY be shown to the user to convey detailed information to users. Adjusted execution \u00b6 Two means MAY be used to adjust the execution of a compendium: environment variables and bind mounts . Environment variables can be set for containers at runtime. They overwrite variables that are defined within the image and thus SHOULD be used sparsely, for example only when the same configuration can not be achieved within the main file, and only to increase reproducibility . The MUST NOT be used for manipulating the compendium\u2019s workflow instead of using UI bindings . Environment variable use case: Time zone A possible use case for environment variables can be setting the time zone. When the display file contains text output of times and timestamps, running the analysis on a machine with a different time zone may wrongly cause errors during checking . While a careful author can cover this within the main file via settings or controlling output, she may also be offered during a creation workflow to freeze the timezone. The following command sets the system time zone to CET . docker run -it --name run_b9b0099e \\ --volume /storage/erc/abc123:/erc --env TZ = CET \\ erc:b9b0099e-9f8d In addition to the mandatory mount of all compendium files, bind mounts MAY be added to replace specific files for substitution . The mounts MUST be configured in a list node bind_mounts under the root-level node execution in the ERC configuration file. Implementations SHOULD apply them in the same order as given in the configuration file. Each mount MUST include the following nodes: source : mount source file or directory. destination : mount target path within the container; MUST be an absolute path. The binds used for substitution MUST be configured as read only. If a list of mounts is configured, it MAY NOT include the mandatory bind mount. Example: data file replacement with bind mounts The following example includes an explicit definition of the mandatory mount to /erc and an overlay bind mount of a CSV file. id: b9b0099e-9f8d spec_version: 1 execution: bind_mounts: - source: '/storage/erc/abc123' destination: /erc - source: /storage/erc/other/input_data/fixed.csv destination: /erc/data.csv It can be translated by an implementation to the following bind string: /storage/compendium/other123/input_data/fixed.csv:/erc/data.csv:ro More on mounts and binds See Docker API specification section Create a container > HostConfig > Binds / Mounts . R workspaces \u00b6 ERC support the R software environment for statistical computing and graphics. Structure \u00b6 The structure (file names for data, directories, etc.) within the ERC are intentionally unspecified. However, the content\u2019s structure MAY follow conventions or be based on templates for organizing research artifacts. If a convention is followed then it SHOULD be referenced in the ERC configuration file as a node convention section. The node\u2019s value can be any text string which uniquely identifies a convention, but a URI or URL to either a human-readable description or formal specification is RECOMMENDED. A non-exhaustive list of potential conventions and guidelines for R is as follows: Ben Marwick\u2019s rrtools ROpenSci rrrpkg Jeff Hollister\u2019s manuscriptPackage Carl Boettiger\u2019s template Francisco Rodriguez-Sanchez\u2019s template Ben Marwick\u2019s template Karl Broman\u2019s comments on reproducibility R package: \u201cWriting R Extensions\u201d Example for using the ROPenSci rrrpkg convention The convention is identified using the public link on GitHub. id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec spec_version: 1 convention: https://github.com/ropensci/rrrpkg R Markdown main file \u00b6 The ERC\u2019s main file for R-based analyses SHOULD be R Markdown . If the main file is R Markdown, it SHOULD include basic metadata in its YAML front matter : author(s), title, date, et cetera. The main document SHOULD NOT contain code that loads pre-computed results from files, but conduct all analyses, even costly ones, during document weaving. The document MUST NOT use cache=TRUE on any of the code chunks (see knitr options . While the previously cached files ( .rdb and .rdx ) MAY be included, they SHOULD NOT be used during the rendering of the document. Note A popular alternative solution is Sweave with the .Rnw extension, which is still widely used for vignettes. R Markdown was chosen of LaTex for its simplicity for users who are unfamiliar with LaTeX. Fixing the environment in code \u00b6 The time zone MUST be fixed to UTC Coordinated Universal Time ) to allow validation of output times (potentially broken by different output formats) by using the following code within the RMarkdown document, or other code to that effect. Sys.setenv ( \"TZ\" = \"UTC\" ) The manifest file (i.e. Dockerfile ) MUST run a plain R session without loading .RData files or profiles at startup, i.e. use R --vanilla . Interactive ERC \u00b6 Enabling interaction with the contents of an ERC is a crucial goal of this specification (see Preface ). Therefore this section defines metadata to support two goals: aide inspecting users to identify core functions and parameters of an analysis, and allow supporting software tools to create interactive renderings of ERC contents for manipulation . These goals are manifested in the UI bindings as part of the ERC configuration file under the root level property ui_bindings . The license of code specifically included to support UI bindings MUST be the same as the code license. An ERC MUST denote if UI bindings are present using the boolean property interactive . If the property is missing it defaults to false . An implementation MAY use the indicator interactive: true to provide other means of displaying the display file. Example for minimal interaction configuration id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec spec_version: 1 ui_bindings: interactive: true An ERC MAY embed multiple concrete UI bindings. Each UI binding is represented by a YAML dictionary. It MUST comprise a purpose and a widget using the fields purpose respectively widget (both of type string). The values of these fields SHOULD use a concept of an ontology to clearly identify their meaning. A purpose defines the user\u2019s intention, for example manipulating a variable or inspecting dataset or code. A widget realizes the purpose with a concrete interaction paradigm chosen by the author, for example an input slider, a form field, or a button. For each widget, implementations MAY use the properties code , data , and text to further describe how a specific UI binding acts upon the respective part of the ERC. Example of two UI bindings id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec spec_version: 1 ui_bindings: interactive: true bindings: - purpose: http://.../data-inspection widget: http://.../tabular-browser code: [...] data: [...] text: [...] - purpose: http://.../parameter-manipulation widget: http://.../dropdown Preservation of ERC \u00b6 This section places the ERC in the context of preservation workflows by defining structural information and other metadata that guarantee interpretability and enable the bundling of the complete ERC as a self-contained, archivable digital object. Archival bundle \u00b6 For the purpose of transferring and storing a complete ERC, it MUST be packaged using the BagIt File Packaging Format (V0.97) (BagIt) as the outer container. BagIt allows to store and transfer arbitrary content along with minimal metadata as well as checksum based payload validation. The remainder of this section comprises a description of the outer container, a BagIt profile, a package leaflet, and secondary metadata files. BagIt outer container \u00b6 The ERC base directory MUST be the BagIt payload directory data/ . The path to the ERC configuration file subsequently MUST be <path-to-bag>/data/erc.yml . The bag metadata file bagit.txt MUST contain the case-sensitive label Is-Executable-Research-Compendium with the case-insensitive value true to mark the bag as the outer container of an ERC. Implementations SHOULD use this field to identify an ERC. Example bagit.txt Payload-Oxum: 2172457623.43 Bagging-Date: 2016-02-01 Bag-Size: 2 GB Is-Executable-Research-Compendium: true Example file tree for a bagged ERC \u251c\u2500\u2500 bag-info.txt \u251c\u2500\u2500 bagit.txt \u251c\u2500\u2500 data \u2502 \u251c\u2500\u2500 2016-07-17-sf2.Rmd \u2502 \u251c\u2500\u2500 erc.yml \u2502 \u251c\u2500\u2500 metadata.json \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u2514\u2500\u2500 image.tar \u251c\u2500\u2500 manifest-md5.txt \u2514\u2500\u2500 tagmanifest-md5.txt BagIt profile - DRAFT \u00b6 Note The elements of the o2r Bagit Profile is yet to be specified. This section is under development. Current BagIt tools do not include an option to add a BagIt Profile automatically. A BagIt Profile as outlined below would make the requirements more explicit. The BagIt Profiles Specification Draft allows users of BagIt bags to coordinate additional information, attached to bags. { \"BagIt-Profile-Info\" :{ \"BagIt-Profile-Identifier\" : \"https://o2r.info/erc-bagit-v1.json\" , \"Source-Organization\" : \"o2r.info\" , \"Contact-Name\" : \"o2r Team\" , \"Contact-Email\" : \"o2r@uni-muenster.de\" , \"External-Description\" : \"BagIt profile for packaging executable research compendia.\" , \"Version\" : \"1\" }, \"Bag-Info\" :{ \"Contact-Name\" :{ \"required\" : true }, \"Contact-Email\" :{ \"required\" : true }, \"External-Identifier\" :{ \"required\" : true }, \"Bag-Size\" :{ \"required\" : true }, \"Payload-Oxum\" :{ \"required\" : true } }, \"Manifests-Required\" :[ \"md5\" ], \"Allow-Fetch.txt\" : false , \"Serialization\" : \"optional\" , \"Accept-Serialization\" :[ \"application/zip\" ], \"Tag-Manifests-Required\" :[ \"md5\" ], \"Tag-Files-Required\" :[ \".erc/metadata.json\" , \"erc.yml\" ], \"Accept-BagIt-Version\" :[ \"0.96\" ] } Package leaflet \u00b6 Each ERC MUST contain a package leaflet, describing the schemas and standards used. Available schema files are supposed to be included with the ERC, if available (licenses for these schemas may apply). Example package leaflet { \"standards_used\" : [ { \"o2r\" : { \"map_description\" : \"maps raw extracted metadata to o2r schema compliant metadata\" , \"mode\" : \"json\" , \"name\" : \"o2r\" , \"outputfile\" : \"metadata_o2r.json\" , \"root\" : \"\" } }, { \"zenodo_sandbox\" : { \"map_description\" : \"maps o2r schema compliant MD to Zenodo Sandbox for deposition creation\" , \"mode\" : \"json\" , \"name\" : \"zenodo_sandbox\" , \"outputfile\" : \"metadata_zenodo_sandbox.json\" , \"root\" : \"metadata\" } } ] } Elements used for each schema standard used are contributed via the MD mapping files in the o2r meta tool suite. Secondary metadata files \u00b6 The ERC as an object can be used in a broad range of cases. For example, it can be an item under review during a journal publication, it can be the actual publication at a workshop or conference or it can be a preserved item in a digital archive. All of these have their own standards and requirements to apply, when it comes to metadata. These metadata requirements are not part of this specification, but the following conventions are made to simplify and coordinate the variety. Metadata specific to a particular domain or use case MUST replicate the information required for the specific case in an independent file. Domain metadata SHOULD follow domain conventions and standards regarding format and encoding of metadata. Duplicate information is accepted, because it lowers the entry barrier for domain experts and systems, who can simply pick up a metadata copy in a format known to them. Metadata documents of specific use cases MUST be stored in a directory .erc , which is a child-directory of the ERC base directory. Metadata documents SHOULD be named according to the used standard/model, format/encoding, and version, e.g. datacite40.xml or zenodo_sandbox10.json , and SHOULD use a suitable mime type. Requirements of secondary metadata \u00b6 In order to comply to their governing schemas, secondary metadata must include the mandatory information as set by 3rd party services. While the documentation of this quality is a perpetual task, we have gathered the information most relevant our selection of connected services. Zenodo Accepts metadata as JSON . Mandatory elements: Upload Type (e.g. Publication) Publication Type Title Creators Description Publication Date Access Right License DataCite (4.0) Accepts metadata as XML . Mandatory elements: Identifier Creator Title Publisher Publication Year Resource Type Development bundle \u00b6 While complete ERCs are focus of this specification, for collaboration and offline inspection it is useful to provide access to parts of the ERC. To support such use cases, a development bundle MAY be provided by implementations. This bundle most importantly would not include the runtime image , which is potentially a large file. The development bundle SHOULD always include the main file and (e.g. by choice of the user, or by an implementing platform) MAY include other relevant files for reproduction or editing purposes outside of the runtime environment, such as input data or the runtime manifest for manual environment recreation. Content metadata \u00b6 The current JSON dummy file to visualises the properties. These elements SHOULD be filled out as good as possible in the user interface. { \"access_right\" : \"open\" , \"author\" : [{ \"name\" : null , \"affiliation\" : [], \"orcid\" : null }], \"codefiles\" : [], \"community\" : \"o2r\" , \"depends\" : [{ \"identifier\" : null , \"version\" : null , \"packageSystem\" : null }], \"description\" : null , \"file\" : { \"filename\" : null , \"filepath\" : null , \"mimetype\" : null }, \"generatedBy\" : null , \"identifier\" : { \"doi\" : null , \"doiurl\" : null , \"reserveddoi\" : null }, \"inputfiles\" : [], \"keywords\" : [], \"license\" : { \"text\" : No ne , \"data\" : No ne , \"code\" : No ne , \"md\" : No ne }, \"paperLanguage\" : [], \"paperSource\" : null , \"publicationDate\" : null , \"recordDateCreated\" : null , \"softwarePaperCitation\" : null , \"spatial\" : { \"files\" : [], \"union\" : [] }, \"temporal\" : { \"begin\" : null , \"end\" : null }, \"title\" : null , \"upload_type\" : \"publication\" , \"viewfiles\" : [] } The path to the o2r metadata file MUST be <path-to-bag>/data/metadata_raw.json and the refined version metadata_o2r.json . Description of o2r metadata properties \u00b6 access_right String . creators Array of objects . creators.name String . creators.orcid String . creators.affiliation String . codefiles Array of strings List of all files of the recursively parsed workspace that have an extension belonging to a (\u201cR\u201d) codefile. communities Array of objects prepared zenodo MD element communities[0].identifier String . Indicating the collection as required in zenodo MD, default \u201co2r\u201d. depends Array of objects . depends.operatingSystem String . depends.identifier String . depends.packageSystem String . URL depends.version String . description String . A text representation conveying the purpose and scope of the asset (the abstract). displayfile String . The suggested file for viewing the text of the workspace, i.e. a rendering of the suggested mainfile. displayfile_candidates Array of strings . An unsorted list of candidates for displayfiles. identifier Object . inputfiles Array of strings . A compiled list of files from the extracted workspace that is called or used in the extracted code of the workspace. interaction TBD keywords Array of strings . Tags associated with the asset. license Object . License information for the entire ERC. license.code String . License information for the code included. license.data String . License information for the data included. license.md String . License information for the metadata included. Should be cc0 to include in catalogues. license.text String . License information for the text included. mainfile String . The suggested main file of workspace mainfile_candidates Array . Unsorted list of mainfile candidates of the workspace. paperLanguage Array of strings . List of guessed languages for the workspace. publication_date String . The publication date of the paper publication as ISO8601 string. publication_type String . related_identifier String . spatial Object . Spatial information of the workspace. spatial.files Array of objects . spatial.union Array of objects . temporal Object . Aggregated information about the relevant time period of the underlying data sets. temporal.begin temporal.end title The distinguishing name of the paper publication. upload_type String. Zenodo preset. Defaults to \u201cpublication\u201d. ERC checking \u00b6 Procedure \u00b6 A core feature ERCs are intended to support is comparing the output of an ERC executions with the original outputs. Therefore checking an ERC always comprises two steps: the execution and the comparison. The files included in the comparison are the comparison set . The comparison set MUST include the display file. It MAY include any other files. An implementation MUST communicate the comparison set to the user as part of a check. Previous to the check, an implementation SHOULD conduct a basic validation of the outer container\u2019s integrity, i.e. check the file hashes. The output of the image execution MAY be shown to the user to convey detailed information on progress or errors. Comparison set file \u00b6 The ERC MAY contain a file named .ercignore in the base directory to define the comparison set. Its purpose is to provide a way to efficiently exclude files and directories from checking . If this file is present, any files and directories within the outer container which match the patterns within the file .ercignore will be excluded from the checking process. The check MUST NOT fail when files listed in .ercignore are failing comparison. The file MUST be UTF-8 (without BOM) encoded. The newline-separated patterns in the file MUST be Unix shell globs and support the prefix ! (see man gitignore ). For the purposes of matching, the root of the context is the ERC\u2019s base directory. Lines starting with # are treated as comments and MUST be ignored by implementations. Example .ercignore file # comment .erc */temp* data-old/* Recommended .ercignore file comparing only the display file Assuming the display file is named display.html , the following `.ercignore ignores all files except the display file. !display.html Note If using md5 file hashes for comparison, the set could include plain text files, for example the text/* media types (see IANA\u2019s full list of media types . Of course the comparison set should include files which contain results of an analysis. Comparing the display file \u00b6 Readers make the ultimate decision about the results of a check, but they tools SHOULD assist them as much as possible to compare the display file generated by the original author with the display file generated during a check , manipulation , or substitution . Tools MAY include other files than the non-display files in a check, but authors SHOULD make sure that the display files contains suitable computational results to judge the outcome of the analysis. Comparing text output SHOULD utilise established file comparison and difference, or \u201cdiff tools\u201d, which the text-based HTML format allows very well. Comparing graphics included in the display file SHOULD also provide visual comparison results, e.g. on a pixel-by-pixel basis or even conceptual differences of images (\u201cperceptual hashes\u201d). Comprehensive example of erc.yml \u00b6 The following example shows all possible fields of the ERC specification with example values. id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec spec_version: 1 main: paper.rmd display: paper.html execution: bind_mounts: ... licenses: code: MIT data: ODbL-1.0 text: \"data_licenses_info.pdf\" metadata: CC0-1.0 convention: https://github.com/ropensci/rrrpkg ui_bindings: interactive: true bindings: - purpose: http://.../data-inspection widget: http://.../tabular-browser code: [...] data: [...] text: [...] - purpose: http://.../parameter-manipulation widget: http://.../dropdown","title":"ERC specification"},{"location":"spec/#erc-specification","text":"An Executable Research Compendium (ERC) is a packaging convention for computational research. It provides a well-defined structure for data, code, text, documentation, and user interface controls for a piece of research and is suitable for long-term archival. As such it can also be perceived as a digital object or asset. Note This is a draft specification. If you have comments or suggestions please file them in the issue tracker . If you have explicit changes please fork the git repo and submit a pull request.","title":"ERC specification"},{"location":"spec/#preface","text":"","title":"Preface"},{"location":"spec/#version","text":"Specification version: 1 Warning This version is under development !","title":"Version"},{"location":"spec/#notational-conventions","text":"The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d are to be interpreted as described in RFC 2119 . The key words \u201cunspecified\u201d, \u201cundefined\u201d, and \u201cimplementation-defined\u201d are to be interpreted as described in the rationale for the C99 standard .","title":"Notational conventions"},{"location":"spec/#purpose-target-audience-and-context","text":"This specification defines a structure to transport and execute a computational scientific analysis (cf. computational science ). It carries technical and conceptual details on how to implement tools to enhance reproducibility and is most suitable for developers . Authors may feel more comfortable with the user guides . These analyses typically comprise a digital workspace on a researcher\u2019s computer, which contains data ( born digital , simulated, or other), code , third party software or libraries, and outputs of research such as digital plots or data. Code and libraries are required in executable form to re-do a specific analysis or workflow. Research is only put into a context by a text , e.g. a research paper, which is published in scholarly communication . The text comes in two forms: one that is machine readable, and another one that is suitable for being viewed by humans. The latter is derived, or \u201crendered\u201d, from the former. The viewing experience can be static, textual, visual, or interactive. Putting all of these elements in a self-contained bundle allows examining, reproducing, transferring, archiving, and formally validating computational research results in a time frame for peer review and collaboration. The ERC specification defines metadata and file structures to support these actions.","title":"Purpose, target audience, and context"},{"location":"spec/#major-constituents","text":"Three major constituents group possible user interactions with ERC. Create Creation is transforming a workspace with data, code and text into an ERC. Examine Examination is evaluating ERC at different levels, from inspecting contents to creating derived analyses. Discover Discovery is searching for content powered by ERC properties, such as text, content metadata, code metadata et cetera.","title":"Major constituents"},{"location":"spec/#design-principles","text":"Simplicity This specification should not re-do something which already exists (if it is an open specification or tool). The risk of scattering information is mitigated by clear documentation. It must be possible to create a valid and working ERC manually , while supporting tools should be able to cover typical use cases with minimal required input by a creating user. Nested containers We acknowledge well defined standards for packaging a set of files, and different approaches to create an executable code package. Therefore an ERC comprises one or more containers but is itself subject to being put into a container . We distinguish these containers into the inner or \u201cruntime\u201d container and the outer container, which is used for transfer of complete ERC and not content-aware validation. Transparency, Stability, and Openness Plain text files usable by both humans and computers are the backbone to make sure ERCs are acceptable by users from all scientific domains, are understandable today and tomorrow, and are easy to extend. The ERC contains everything needed to execute a workflow.","title":"Design principles"},{"location":"spec/#how-to-use-an-erc","text":"The steps to (re-)run the analysis contained in an ERC as part of an examination are as follows: (if compressed first extract then) unpack the ERC\u2019s outer container execute the runtime container compare the output files contained in the outer container with the output files just created by the runtime container This way an ERC allows computational reproducibility based on the original code and data.","title":"How to use an ERC"},{"location":"spec/#three-questions","text":"[Section inspired by REANA\u2019s \u201cFour Questions\u201d ] The ERC helps to make research papers more transparent an reusable by giving minimal structure for contents and context. They help to answer the \u201cThree Questions\u201d both for users, but more importantly for tools and services built around them. What is your result? file I should look at to see the description and visualisations the \u201cdisplay file\u201d shown by applications based on ERC What is your workflow? file I should look at as a reader when I want to understand your code/analysis/workflow, the steps you took the \u201cmain file\u201d used by applications based on ERC for creating ERCs and executing them, which means running the analysis and creating the result What is your environment? operating system you used software you used (libraries, your own scripts, \u2026) can be used by tools to recreate the same environment","title":"Three questions"},{"location":"spec/#erc-structure","text":"","title":"ERC structure"},{"location":"spec/#base-directory","text":"An ERC MUST has a base directory . All paths within this document are relative to this base directory. The base directory MUST contain an ERC configuration file . Besides the files mentioned in this specification, the base directory MAY contain any other files and directories.","title":"Base directory"},{"location":"spec/#main-display-file","text":"An ERC MUST have a main file, i.e. the file which contains the text and instructions being the basis for the scientific publication describing the packaged analysis. An ERC MUST have a _display file , i.e. the file which is shown to a user first when she opens an ERC in a supporting platform or tool. Main file and display file MUST NOT be the same file. The main file MUST be executable in the sense that a software reads it as the input of a process to create the display file . The main file \u2018s name SHOULD be main with an appropriate file extension and media type . Note The main file thus follows the literate programming paradigm . Example If the main file is an R Markdown document, then the file extension should be .Rmd and the media type text/markdown . A file main.Rmd will consequently be automatically identified by an implementation as the ERC\u2019s main file . The display file\u2019s name SHOULD be display with an appropriate file extension and media type. Example If the display file is an Hypertext Markup Language (HTML) document, then the file extension should be .htm or .html and the media type text/html . A file display.html will consequently be automatically identified by an implementation as the ERC\u2019s display file . The ERC MAY use an interactive document with interactive figures and control elements for the packaged computations as the display file . The interactive display file MUST have HTML format and SHOULD be valid HTML5 . Example Typical examples for the two core documents are R Markdown with HTML output (i.e. main.Rmd and display.html ), or an R script creating a PNG file (i.e. main.R and display.png ).","title":"Main &amp; display file"},{"location":"spec/#nested-runtime","text":"The embedding of a representation of the original runtime environment, in which the analysis was conducted, is crucial for supporting reproducible computations. Every ERC MUST include two such such representations: an executable runtime image of the original analysis environment for re-running the packaged analysis, and a runtime manifest documenting the image\u2019s contents as a complete, self-consistent recipe of the runtime image\u2019s contents which is a machine-readable format that allows a respective tool to create the runtime image. The image MUST be stored as a file, e.g. a \u201cbinary\u201d or \u201carchive\u201d, in the ERC base directory. The manifest MUST be stored as a text file in the ERC base directory. System environment The nested runtime encapsulates software, files, and configurations up to a specific level of abstraction. It may not include a complete operating system, for example for better performance or security reasons. While this information is included in the nested runtime, it MUST be accessible without executing the runtime. Hard to obtain information SHOULD be replicated in the configuration file. If the nested runtime does not include the operating system, then the configuration file MUST include the following data about the environment used to create the ERC: architecture operating system kernel (if applicable) runtime software version An implementation SHOULD notify the user if the provided system environment is incompatible with the implementations capabilities. Tip A partially incompatible system environment, especially a different kernel version, may still produce the desired result, as breaking changes are very rare. An implementation may utilise semantic versioning to improve its compatibility tests. An incompatible operating system, e.g. linux vs. windows , and architecture, e.g. amd64 or arm/v7 , are likely to fail.","title":"Nested runtime"},{"location":"spec/#erc-configuration-file","text":"The ERC configuration file is the reproducibility manifest for an ERC. It defines the main entry points for actions performed on an ERC and core metadata elements.","title":"ERC configuration file"},{"location":"spec/#name-format-and-encoding","text":"The filename MUST be erc.yml and it MUST be located in the base directory. The contents MUST be valid YAML 1.2 . The file MUST be encoded in UTF-8 and MUST NOT contain a byte-order mark (BOM).","title":"Name, format, and encoding"},{"location":"spec/#basic-fields","text":"The first document content of this file MUST contain the following string nodes at the root level. spec_version : a text string noting the version of the used ERC specification. The appropriate version for an ERC conforming to this version of the specification is 1 . id : globally unique identifier for a specific ERC. id MUST not be empty and MUST only contain lowercase letters, uppercase letters, digits and single separators. Valid separators are period, underscore, or dash. A name component MUST NOT start or end with a separator. An implementation MAY introduce further restrictions on minimum and maximum length of identifiers. Note While URIs (see rfc3986 ) are very common identifiers, not all systems support them as identifiers. For example they cannot be used for Docker image names. A UUID is a valid id . A regular expression to validate identifiers is /^[^-_.][a-zA-Z0-9._-]+[^-_.]$/ . The main and display file MAY be defined in root-level nodes named main and display respectively. If they are not defined and multiple documents use the name main.[ext] or display.[ext] , an implementation SHOULD use the first file in alphabetical order . Example of ERC configuration file with user-defined main and display files id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec spec_version: 1 main: workflow.Rmd display: paper.html Additionally, related resources such as a related publication can be stated with the relatedIdentifier element field. A related identifier SHOULD be a globally unique persistent identifier and SHOULD be a URI.","title":"Basic fields"},{"location":"spec/#author-and-license-metadata","text":"The main document MUST include information about the authors. It SHOULD contain this information in a structured way so it can be parsed by tools supporting ERCs. Note An example for structured metadata is markup with author names and affiliations in the header of the main document. The file erc.yml MUST contain a first level node licenses with licensing information for contained artefacts. Each of these artefacts, e.g. code or data, have distinct requirements so it must be possible to apply different licenses. The node licenses MUST have four child nodes: text , data , code , and metadata . Note There is currently no mechanism to define the licenses of all the used libraries and software in a structured format. Manual creation would be tedious. Tools for automatic creation of ERC may add such detailed licensing information and define additional metadata elements. The content of each of these child nodes MUST be a string with one of the following contents: license identifier as defined by the Open Definition Licenses Service name of file with either documentation on licensing or a full license text Example for common licenses id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec spec_version: 1 licenses: code: Apache-2.0 data: ODbL-1.0 text: CC0-1.0 metadata: CC0-1.0 Example for non-standard licenses id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec spec_version: 1 licenses: code: Apache-2.0 data: data-licenses.txt text: \"Creative Commons Attribution 2.0 Generic (CC BY 2.0)\" metadata: \"see metadata license headers\"","title":"Author and license metadata"},{"location":"spec/#runtime-manifest-and-image","text":"The ERC uses Docker to define, build, and store the nested runtime environment.","title":"Runtime manifest and image"},{"location":"spec/#runtime-image","text":"The runtime environment or image MUST be represented by a Docker image v1.2.0 . Note A concrete implementation of ERC may choose to rely on constructing the runtime environment from the manifest when needed, e.g. for export to a repository, while the ERC is constructed. The base directory MUST contain a tarball , i.e. an archive file, of a Docker image as created be the command docker save , see Docker CLI save command documentation , as defined in version 1.12.x . The image MUST have a tag erc:<erc identifier> , for example erc:b9b0099e-9f8d-4a33-8acf-cb0c062efaec . The image file MAY be compressed. The image archive file name MUST be image with an appropriate file extension, such as .tar , .tar.gz (if a gzip compression is used for the archive ) or .bin , and have an appropriate mime type, e.g. application/vnd.oci.image.layer.tar+gzip . Note Before exporting the Docker image, it should be build from the runtime manifest, including the tag which can be used to identify the image, for example: docker build --tag erc:b9b0099e-9f8d . docker images erc:b9b0099e-9f8d docker save erc:b9b0099e-9f8d > image.tar # save with compression: docker save erc:b9b0099e-9f8d | gzip -c > image.tar.gz Do not use docker export , because it is used to create a snapshot of a container, which must not match the Dockerfile anymore as it may have been manipulated during a run.","title":"Runtime image"},{"location":"spec/#runtime-manifest","text":"The runtime manifest MUST be represented by a valid Dockerfile , see Docker builder reference , as defined in version 1.12.x . The file MUST be named Dockerfile . The Dockerfile MUST contain the build instructions for the runtime environment and MUST have been used to create the image saved to the runtime image using docker build , see Docker CLI build command documentation , as defined in version 1.12.x . The build SHOULD be done with the option --no-cache=true . The Dockerfile MUST NOT use the latest tag in the instruction FROM . Note The \u201clatest\u201d tag is merely a convention to denote the latest available image, so any tag can have undesired results. Nevertheless, using an image tagged \u201clatest\u201d makes it much more likely to change over time. Although there is no guarantee that images tagged differently, e.g. \u201cv1.2.3\u201d might not change as well, using such tags shall be enforced here. The Dockerfile SHOULD contain the label maintainer to provide authorship information. The Dockerfile MUST have an active instruction CMD , or a combination of the instructions ENTRYPOINT and CMD , which executes the packaged analysis. The Dockerfile MUST contain a VOLUME instruction to define the mount point of the ERC base directory within the container. This mount point MUST be /erc and the bind MUST be configured as with read and write access . Implementations SHOULD make sure an execution does not interfere with original uploaded files, but a write access is required to store the created display file outside of the container. The Dockerfile MUST contain a WORKDIR instruction with the value /erc . The Dockerfile SHOULD NOT contain a COPY or ADD command to include data, code or text from the ERC into the image. These commands MAY be used to copy code or libraries which must be available during the image build. The Dockerfile SHOULD NOT contain EXPOSE instructions.","title":"Runtime manifest"},{"location":"spec/#system-environment","text":"The following system environment configurations MUST be provided as nodes under the root-level node execution : (if applicable) kernel , node kernel The following system environment configurations are available within the runtime image metadata and therefore not be replicated in the ERC configuration file. operating system , node os , architecture , node architecture runtime software version , node DockerVersion in output of docker inspect and node docker_version in image metadata JSON file (cf. source code ). Accessing system environment configurations from image metadata in a saved image tarball manifest.json contains a list of the layers and the config as the name of the configuration file. The image metadata is in the <image id>.json file in the root directory of the tarball. The following commands show how to extract the image metadata file from the tarball and print the relevant properties to the console using the JSON cli tool jq . $ tar -xf image.tar --wildcards --no-anchored '[!manifest]*.json' $ cat *.json | jq '.architecture, .os, .docker_version' \"amd64\" \"linux\" \"17.05.0-ce\" Together the image metadata and ERC configuration file provide all properties of the underlying system environment. An implementation SHOULD notify the user if the required system environment is incompatible with the implementation\u2019s capabilities. System environment incompatibilities A partially incompatible system environment, especially a different kernel version, may still produce the desired result, as breaking changes are very rare. An implementation could utilise semantic versioning to improve its compatibility tests. An incompatible operating system, e.g. linux vs. windows , and architecture, e.g. amd64 or arm/v7 , are likely to fail. Example of ERC configuration file with user-defined kernel and excerpt from runtime image metadata ERC configuration file id: b9b0099e-9f8d spec_version: 1 execution: kernel: `4.13.0-32-generic` Image metadata (excerpt) (results of an docker image inspect call): [ { \"Id\" : \"sha256:87362162878143c5e10e94a6ec9b7e925b...\" , \"RepoTags\" : [], \"RepoDigests\" : [], \"Parent\" : \"sha256:a280c143ff833d99274e96bbcfdc86...\" , \"Created\" : \"2018-02-15T15:18:42.623467682Z\" , \"Container\" : \"840b75b48121012a0847bbae148ed96df7...\" , \"ContainerConfig\" : { ... }, \"DockerVersion\" : \"17.05.0-ce\" , \"Author\" : \"<https://o2r.info>\" , \"Config\" : { ... }, \"Architecture\" : \"amd64\" , \"Os\" : \"linux\" , [ ... ] } ] Image metadata (excerpt) (content of <image id>.json from image.tar ): { \"architecture\" : \"amd64\" , \"config\" : { ... , \"Labels\" : { \"maintainer\" : \"o2r\" } }, \"container\" : \"747198d654630530c2a6523abbc19e41d7fcf977833c6854a2a48fb11b8c607c\" , \"container_config\" : { ... }, \"created\" : \"2018-03-08T15:24:20.164740334Z\" , \"docker_version\" : \"17.05.0-ce\" , \"history\" : [ ... ], \"os\" : \"linux\" , \"rootfs\" : { \"type\" : \"layers\" , \"diff_ids\" : [ \"sha256:8568818b1f7f534832b393c531edfcb4a30e7eb40b573e68fdea90358987231f\" , \"sha256:fccd38ea8016190426aa7ef4baba29b0c92de1ee863c3460a34151695fbcba08\" , \"sha256:cf52051fff5bb6430c972ef822d435e9b5242117398b43c6d36f1ed71d978a94\" , \"sha256:5535e4fbfa3ed182d3cc87bfe643f87801c91be6c171535675effb4efc8c1e5a\" , \"sha256:9d55d57e41e02115f48e428a880d88d7bf0af993a232d0c967cc17f012e2e250\" ] } }","title":"System environment"},{"location":"spec/#execution","text":"The configuration file MUST provide enough information to for implementations to create the commands for execution of the runtime image and to provide access to the data and software in the ERC. Implementations MUST support Docker Engine API v1.35 (or compatible).","title":"Execution"},{"location":"spec/#making-data-code-and-text-available-within-container","text":"The runtime environment image contains all dependencies and libraries needed by the code in an ERC. Especially for large datasets, it in unfeasible to replicate the complete dataset contained within the ERC in the image. For archival, it can also be confusing to replicate code and text, albeit them potentially being relatively small in size, within the container. Therefore a host directory MUST be mounted (also \u201cbind-mounted\u201d) into the compendium container at runtime using a data volume . Example Dockerfile In this example we use a Rocker base image to reproduce computations made in R. FROM rocker/r-ver:3.3.3 RUN apt-get update -qq \\ && apt-get install -y --no-install-recommends \\ ## Packages required by R extension packages # required by rmarkdown: lmodern \\ pandoc \\ # for devtools ( requires git2r, httr ) : libcurl4-openssl-dev \\ libssl-dev \\ git \\ # for udunits: libudunits2-0 \\ libudunits2-dev \\ # required when knitting the document pandoc-citeproc \\ && apt-get clean \\ && rm -rf /var/lib/apt/lists/* # install R extension packages RUN install2.r -r \"http://cran.rstudio.com\" \\ rmarkdown \\ ggplot2 \\ devtools \\ && rm -rf /tmp/downloaded_packages/ /tmp/*.rd # Save installed packages to file RUN dpkg -l > /dpkg-list.txt LABEL maintainer = o2r \\ description = \"This is an ERC image.\" \\ info.o2r.bag.id = \"123456\" VOLUME [ \"/erc\" ] WORKDIR [\"/erc\"] ENTRYPOINT [ \"sh\" , \"-c\" ] CMD [ \"R --vanilla -e \\\"rmarkdown::render(input = '/erc/myPaper.rmd', \\ output_dir = '/erc', output_format = rmarkdown::html_document())\\\"\" ] Main and display file in the container The fixed mount point have the advantage that users and tools can be sure the main and display files are usually available at /erc/main.Rmd and /erc/display.html respectively.","title":"Making data, code, and text available within container"},{"location":"spec/#default-execution","text":"If no execution information is provided, then the implementation MUST assume an unconfigured Docker control flow for loading and executing the nested runtime environment is sufficient. Unconfigured means that NO configuration besides providing a mount of the compendium files (see previous section) MAY be applied. The control statements for Docker executions comprise load , for importing an image from the archive, and run for starting a container of the loaded image. Both control statements MUST be configured by using nodes of the same name under the root-level node execution in the ERC configuration file. Based on the configuration, an implementation can construct the respective runtime software\u2019s commands, i.e. docker load and docker run , using the correct image file name and further parameters (e.g. performance control options). Constructing the execution commands The Docker CLI commands constructed based on configuration file for ERC with ID b9b0099e-9f8d could be as follows. In this case the implementation uses -it to pass stdout streams to the user and adds an identifier for the container using --name . docker load --input image.tar docker run -it --name run_b9b0099e \\ --volume /storage/erc/abc123:/erc \\ erc:b9b0099e-9f8d The output of the container during execution MAY be shown to the user to convey detailed information to users.","title":"Default execution"},{"location":"spec/#adjusted-execution","text":"Two means MAY be used to adjust the execution of a compendium: environment variables and bind mounts . Environment variables can be set for containers at runtime. They overwrite variables that are defined within the image and thus SHOULD be used sparsely, for example only when the same configuration can not be achieved within the main file, and only to increase reproducibility . The MUST NOT be used for manipulating the compendium\u2019s workflow instead of using UI bindings . Environment variable use case: Time zone A possible use case for environment variables can be setting the time zone. When the display file contains text output of times and timestamps, running the analysis on a machine with a different time zone may wrongly cause errors during checking . While a careful author can cover this within the main file via settings or controlling output, she may also be offered during a creation workflow to freeze the timezone. The following command sets the system time zone to CET . docker run -it --name run_b9b0099e \\ --volume /storage/erc/abc123:/erc --env TZ = CET \\ erc:b9b0099e-9f8d In addition to the mandatory mount of all compendium files, bind mounts MAY be added to replace specific files for substitution . The mounts MUST be configured in a list node bind_mounts under the root-level node execution in the ERC configuration file. Implementations SHOULD apply them in the same order as given in the configuration file. Each mount MUST include the following nodes: source : mount source file or directory. destination : mount target path within the container; MUST be an absolute path. The binds used for substitution MUST be configured as read only. If a list of mounts is configured, it MAY NOT include the mandatory bind mount. Example: data file replacement with bind mounts The following example includes an explicit definition of the mandatory mount to /erc and an overlay bind mount of a CSV file. id: b9b0099e-9f8d spec_version: 1 execution: bind_mounts: - source: '/storage/erc/abc123' destination: /erc - source: /storage/erc/other/input_data/fixed.csv destination: /erc/data.csv It can be translated by an implementation to the following bind string: /storage/compendium/other123/input_data/fixed.csv:/erc/data.csv:ro More on mounts and binds See Docker API specification section Create a container > HostConfig > Binds / Mounts .","title":"Adjusted execution"},{"location":"spec/#r-workspaces","text":"ERC support the R software environment for statistical computing and graphics.","title":"R workspaces"},{"location":"spec/#structure","text":"The structure (file names for data, directories, etc.) within the ERC are intentionally unspecified. However, the content\u2019s structure MAY follow conventions or be based on templates for organizing research artifacts. If a convention is followed then it SHOULD be referenced in the ERC configuration file as a node convention section. The node\u2019s value can be any text string which uniquely identifies a convention, but a URI or URL to either a human-readable description or formal specification is RECOMMENDED. A non-exhaustive list of potential conventions and guidelines for R is as follows: Ben Marwick\u2019s rrtools ROpenSci rrrpkg Jeff Hollister\u2019s manuscriptPackage Carl Boettiger\u2019s template Francisco Rodriguez-Sanchez\u2019s template Ben Marwick\u2019s template Karl Broman\u2019s comments on reproducibility R package: \u201cWriting R Extensions\u201d Example for using the ROPenSci rrrpkg convention The convention is identified using the public link on GitHub. id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec spec_version: 1 convention: https://github.com/ropensci/rrrpkg","title":"Structure"},{"location":"spec/#r-markdown-main-file","text":"The ERC\u2019s main file for R-based analyses SHOULD be R Markdown . If the main file is R Markdown, it SHOULD include basic metadata in its YAML front matter : author(s), title, date, et cetera. The main document SHOULD NOT contain code that loads pre-computed results from files, but conduct all analyses, even costly ones, during document weaving. The document MUST NOT use cache=TRUE on any of the code chunks (see knitr options . While the previously cached files ( .rdb and .rdx ) MAY be included, they SHOULD NOT be used during the rendering of the document. Note A popular alternative solution is Sweave with the .Rnw extension, which is still widely used for vignettes. R Markdown was chosen of LaTex for its simplicity for users who are unfamiliar with LaTeX.","title":"R Markdown main file"},{"location":"spec/#fixing-the-environment-in-code","text":"The time zone MUST be fixed to UTC Coordinated Universal Time ) to allow validation of output times (potentially broken by different output formats) by using the following code within the RMarkdown document, or other code to that effect. Sys.setenv ( \"TZ\" = \"UTC\" ) The manifest file (i.e. Dockerfile ) MUST run a plain R session without loading .RData files or profiles at startup, i.e. use R --vanilla .","title":"Fixing the environment in code"},{"location":"spec/#interactive-erc","text":"Enabling interaction with the contents of an ERC is a crucial goal of this specification (see Preface ). Therefore this section defines metadata to support two goals: aide inspecting users to identify core functions and parameters of an analysis, and allow supporting software tools to create interactive renderings of ERC contents for manipulation . These goals are manifested in the UI bindings as part of the ERC configuration file under the root level property ui_bindings . The license of code specifically included to support UI bindings MUST be the same as the code license. An ERC MUST denote if UI bindings are present using the boolean property interactive . If the property is missing it defaults to false . An implementation MAY use the indicator interactive: true to provide other means of displaying the display file. Example for minimal interaction configuration id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec spec_version: 1 ui_bindings: interactive: true An ERC MAY embed multiple concrete UI bindings. Each UI binding is represented by a YAML dictionary. It MUST comprise a purpose and a widget using the fields purpose respectively widget (both of type string). The values of these fields SHOULD use a concept of an ontology to clearly identify their meaning. A purpose defines the user\u2019s intention, for example manipulating a variable or inspecting dataset or code. A widget realizes the purpose with a concrete interaction paradigm chosen by the author, for example an input slider, a form field, or a button. For each widget, implementations MAY use the properties code , data , and text to further describe how a specific UI binding acts upon the respective part of the ERC. Example of two UI bindings id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec spec_version: 1 ui_bindings: interactive: true bindings: - purpose: http://.../data-inspection widget: http://.../tabular-browser code: [...] data: [...] text: [...] - purpose: http://.../parameter-manipulation widget: http://.../dropdown","title":"Interactive ERC"},{"location":"spec/#preservation-of-erc","text":"This section places the ERC in the context of preservation workflows by defining structural information and other metadata that guarantee interpretability and enable the bundling of the complete ERC as a self-contained, archivable digital object.","title":"Preservation of ERC"},{"location":"spec/#archival-bundle","text":"For the purpose of transferring and storing a complete ERC, it MUST be packaged using the BagIt File Packaging Format (V0.97) (BagIt) as the outer container. BagIt allows to store and transfer arbitrary content along with minimal metadata as well as checksum based payload validation. The remainder of this section comprises a description of the outer container, a BagIt profile, a package leaflet, and secondary metadata files.","title":"Archival bundle"},{"location":"spec/#bagit-outer-container","text":"The ERC base directory MUST be the BagIt payload directory data/ . The path to the ERC configuration file subsequently MUST be <path-to-bag>/data/erc.yml . The bag metadata file bagit.txt MUST contain the case-sensitive label Is-Executable-Research-Compendium with the case-insensitive value true to mark the bag as the outer container of an ERC. Implementations SHOULD use this field to identify an ERC. Example bagit.txt Payload-Oxum: 2172457623.43 Bagging-Date: 2016-02-01 Bag-Size: 2 GB Is-Executable-Research-Compendium: true Example file tree for a bagged ERC \u251c\u2500\u2500 bag-info.txt \u251c\u2500\u2500 bagit.txt \u251c\u2500\u2500 data \u2502 \u251c\u2500\u2500 2016-07-17-sf2.Rmd \u2502 \u251c\u2500\u2500 erc.yml \u2502 \u251c\u2500\u2500 metadata.json \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u2514\u2500\u2500 image.tar \u251c\u2500\u2500 manifest-md5.txt \u2514\u2500\u2500 tagmanifest-md5.txt","title":"BagIt outer container"},{"location":"spec/#bagit-profile-draft","text":"Note The elements of the o2r Bagit Profile is yet to be specified. This section is under development. Current BagIt tools do not include an option to add a BagIt Profile automatically. A BagIt Profile as outlined below would make the requirements more explicit. The BagIt Profiles Specification Draft allows users of BagIt bags to coordinate additional information, attached to bags. { \"BagIt-Profile-Info\" :{ \"BagIt-Profile-Identifier\" : \"https://o2r.info/erc-bagit-v1.json\" , \"Source-Organization\" : \"o2r.info\" , \"Contact-Name\" : \"o2r Team\" , \"Contact-Email\" : \"o2r@uni-muenster.de\" , \"External-Description\" : \"BagIt profile for packaging executable research compendia.\" , \"Version\" : \"1\" }, \"Bag-Info\" :{ \"Contact-Name\" :{ \"required\" : true }, \"Contact-Email\" :{ \"required\" : true }, \"External-Identifier\" :{ \"required\" : true }, \"Bag-Size\" :{ \"required\" : true }, \"Payload-Oxum\" :{ \"required\" : true } }, \"Manifests-Required\" :[ \"md5\" ], \"Allow-Fetch.txt\" : false , \"Serialization\" : \"optional\" , \"Accept-Serialization\" :[ \"application/zip\" ], \"Tag-Manifests-Required\" :[ \"md5\" ], \"Tag-Files-Required\" :[ \".erc/metadata.json\" , \"erc.yml\" ], \"Accept-BagIt-Version\" :[ \"0.96\" ] }","title":"BagIt profile - DRAFT"},{"location":"spec/#package-leaflet","text":"Each ERC MUST contain a package leaflet, describing the schemas and standards used. Available schema files are supposed to be included with the ERC, if available (licenses for these schemas may apply). Example package leaflet { \"standards_used\" : [ { \"o2r\" : { \"map_description\" : \"maps raw extracted metadata to o2r schema compliant metadata\" , \"mode\" : \"json\" , \"name\" : \"o2r\" , \"outputfile\" : \"metadata_o2r.json\" , \"root\" : \"\" } }, { \"zenodo_sandbox\" : { \"map_description\" : \"maps o2r schema compliant MD to Zenodo Sandbox for deposition creation\" , \"mode\" : \"json\" , \"name\" : \"zenodo_sandbox\" , \"outputfile\" : \"metadata_zenodo_sandbox.json\" , \"root\" : \"metadata\" } } ] } Elements used for each schema standard used are contributed via the MD mapping files in the o2r meta tool suite.","title":"Package leaflet"},{"location":"spec/#secondary-metadata-files","text":"The ERC as an object can be used in a broad range of cases. For example, it can be an item under review during a journal publication, it can be the actual publication at a workshop or conference or it can be a preserved item in a digital archive. All of these have their own standards and requirements to apply, when it comes to metadata. These metadata requirements are not part of this specification, but the following conventions are made to simplify and coordinate the variety. Metadata specific to a particular domain or use case MUST replicate the information required for the specific case in an independent file. Domain metadata SHOULD follow domain conventions and standards regarding format and encoding of metadata. Duplicate information is accepted, because it lowers the entry barrier for domain experts and systems, who can simply pick up a metadata copy in a format known to them. Metadata documents of specific use cases MUST be stored in a directory .erc , which is a child-directory of the ERC base directory. Metadata documents SHOULD be named according to the used standard/model, format/encoding, and version, e.g. datacite40.xml or zenodo_sandbox10.json , and SHOULD use a suitable mime type.","title":"Secondary metadata files"},{"location":"spec/#requirements-of-secondary-metadata","text":"In order to comply to their governing schemas, secondary metadata must include the mandatory information as set by 3rd party services. While the documentation of this quality is a perpetual task, we have gathered the information most relevant our selection of connected services. Zenodo Accepts metadata as JSON . Mandatory elements: Upload Type (e.g. Publication) Publication Type Title Creators Description Publication Date Access Right License DataCite (4.0) Accepts metadata as XML . Mandatory elements: Identifier Creator Title Publisher Publication Year Resource Type","title":"Requirements of secondary metadata"},{"location":"spec/#development-bundle","text":"While complete ERCs are focus of this specification, for collaboration and offline inspection it is useful to provide access to parts of the ERC. To support such use cases, a development bundle MAY be provided by implementations. This bundle most importantly would not include the runtime image , which is potentially a large file. The development bundle SHOULD always include the main file and (e.g. by choice of the user, or by an implementing platform) MAY include other relevant files for reproduction or editing purposes outside of the runtime environment, such as input data or the runtime manifest for manual environment recreation.","title":"Development bundle"},{"location":"spec/#content-metadata","text":"The current JSON dummy file to visualises the properties. These elements SHOULD be filled out as good as possible in the user interface. { \"access_right\" : \"open\" , \"author\" : [{ \"name\" : null , \"affiliation\" : [], \"orcid\" : null }], \"codefiles\" : [], \"community\" : \"o2r\" , \"depends\" : [{ \"identifier\" : null , \"version\" : null , \"packageSystem\" : null }], \"description\" : null , \"file\" : { \"filename\" : null , \"filepath\" : null , \"mimetype\" : null }, \"generatedBy\" : null , \"identifier\" : { \"doi\" : null , \"doiurl\" : null , \"reserveddoi\" : null }, \"inputfiles\" : [], \"keywords\" : [], \"license\" : { \"text\" : No ne , \"data\" : No ne , \"code\" : No ne , \"md\" : No ne }, \"paperLanguage\" : [], \"paperSource\" : null , \"publicationDate\" : null , \"recordDateCreated\" : null , \"softwarePaperCitation\" : null , \"spatial\" : { \"files\" : [], \"union\" : [] }, \"temporal\" : { \"begin\" : null , \"end\" : null }, \"title\" : null , \"upload_type\" : \"publication\" , \"viewfiles\" : [] } The path to the o2r metadata file MUST be <path-to-bag>/data/metadata_raw.json and the refined version metadata_o2r.json .","title":"Content metadata"},{"location":"spec/#description-of-o2r-metadata-properties","text":"access_right String . creators Array of objects . creators.name String . creators.orcid String . creators.affiliation String . codefiles Array of strings List of all files of the recursively parsed workspace that have an extension belonging to a (\u201cR\u201d) codefile. communities Array of objects prepared zenodo MD element communities[0].identifier String . Indicating the collection as required in zenodo MD, default \u201co2r\u201d. depends Array of objects . depends.operatingSystem String . depends.identifier String . depends.packageSystem String . URL depends.version String . description String . A text representation conveying the purpose and scope of the asset (the abstract). displayfile String . The suggested file for viewing the text of the workspace, i.e. a rendering of the suggested mainfile. displayfile_candidates Array of strings . An unsorted list of candidates for displayfiles. identifier Object . inputfiles Array of strings . A compiled list of files from the extracted workspace that is called or used in the extracted code of the workspace. interaction TBD keywords Array of strings . Tags associated with the asset. license Object . License information for the entire ERC. license.code String . License information for the code included. license.data String . License information for the data included. license.md String . License information for the metadata included. Should be cc0 to include in catalogues. license.text String . License information for the text included. mainfile String . The suggested main file of workspace mainfile_candidates Array . Unsorted list of mainfile candidates of the workspace. paperLanguage Array of strings . List of guessed languages for the workspace. publication_date String . The publication date of the paper publication as ISO8601 string. publication_type String . related_identifier String . spatial Object . Spatial information of the workspace. spatial.files Array of objects . spatial.union Array of objects . temporal Object . Aggregated information about the relevant time period of the underlying data sets. temporal.begin temporal.end title The distinguishing name of the paper publication. upload_type String. Zenodo preset. Defaults to \u201cpublication\u201d.","title":"Description of o2r metadata properties"},{"location":"spec/#erc-checking","text":"","title":"ERC checking"},{"location":"spec/#procedure","text":"A core feature ERCs are intended to support is comparing the output of an ERC executions with the original outputs. Therefore checking an ERC always comprises two steps: the execution and the comparison. The files included in the comparison are the comparison set . The comparison set MUST include the display file. It MAY include any other files. An implementation MUST communicate the comparison set to the user as part of a check. Previous to the check, an implementation SHOULD conduct a basic validation of the outer container\u2019s integrity, i.e. check the file hashes. The output of the image execution MAY be shown to the user to convey detailed information on progress or errors.","title":"Procedure"},{"location":"spec/#comparison-set-file","text":"The ERC MAY contain a file named .ercignore in the base directory to define the comparison set. Its purpose is to provide a way to efficiently exclude files and directories from checking . If this file is present, any files and directories within the outer container which match the patterns within the file .ercignore will be excluded from the checking process. The check MUST NOT fail when files listed in .ercignore are failing comparison. The file MUST be UTF-8 (without BOM) encoded. The newline-separated patterns in the file MUST be Unix shell globs and support the prefix ! (see man gitignore ). For the purposes of matching, the root of the context is the ERC\u2019s base directory. Lines starting with # are treated as comments and MUST be ignored by implementations. Example .ercignore file # comment .erc */temp* data-old/* Recommended .ercignore file comparing only the display file Assuming the display file is named display.html , the following `.ercignore ignores all files except the display file. !display.html Note If using md5 file hashes for comparison, the set could include plain text files, for example the text/* media types (see IANA\u2019s full list of media types . Of course the comparison set should include files which contain results of an analysis.","title":"Comparison set file"},{"location":"spec/#comparing-the-display-file","text":"Readers make the ultimate decision about the results of a check, but they tools SHOULD assist them as much as possible to compare the display file generated by the original author with the display file generated during a check , manipulation , or substitution . Tools MAY include other files than the non-display files in a check, but authors SHOULD make sure that the display files contains suitable computational results to judge the outcome of the analysis. Comparing text output SHOULD utilise established file comparison and difference, or \u201cdiff tools\u201d, which the text-based HTML format allows very well. Comparing graphics included in the display file SHOULD also provide visual comparison results, e.g. on a pixel-by-pixel basis or even conceptual differences of images (\u201cperceptual hashes\u201d).","title":"Comparing the display file"},{"location":"spec/#comprehensive-example-of-ercyml","text":"The following example shows all possible fields of the ERC specification with example values. id: b9b0099e-9f8d-4a33-8acf-cb0c062efaec spec_version: 1 main: paper.rmd display: paper.html execution: bind_mounts: ... licenses: code: MIT data: ODbL-1.0 text: \"data_licenses_info.pdf\" metadata: CC0-1.0 convention: https://github.com/ropensci/rrrpkg ui_bindings: interactive: true bindings: - purpose: http://.../data-inspection widget: http://.../tabular-browser code: [...] data: [...] text: [...] - purpose: http://.../parameter-manipulation widget: http://.../dropdown","title":"Comprehensive example of erc.yml"},{"location":"user-guide/creation/","text":"User guide: ERC creation \u00b6 This user guide comprises instructions how to create an ERC by hand . It is thus limited to mandatory elements in some places. However, a fundamental goal of the ERC specification is to be simple enough to allow manual ERC creation as demonstrated in this document. It is supposed to ease the understanding of the ERC especially for the authors of scientific publications. For using tools or services for creation and validation of ERCs, please see the developer guide . Note This is a draft. If you have comments or suggestions please file them in the issue tracker . If you have explicit changes please fork the git repo and submit a pull request. Step 1: create workspace \u00b6 Do your research and create something useful that works for you. The ERC specification makes no restrictions on the contents of a workspace, but guidelines and best practices do exist and should be followed by users during their research i.e. even before packaging it in an ERC. Code and versioning \u00b6 If the base directory contains a script file or source code used to conduct the packaged analysis, we recommend this code is managed using distributed version control , see software carpentry guidelines . The base directory should contain a copy of the complete repository in that case. Workspace structure \u00b6 The base directory contents should follow common guidelines to project organisation. Some useful resources are Software carpentry paper \u201cGood enough practices in Scientific Computing\u201d ROpenSci research compendium ). ROpenSci reproducibility guide Step 2: create image container for runtime \u00b6 To create a working ERC you must include a complete environment description and an executable image. We recommend using Docker, so a Dockerfile and a Docker image tarball archive file, to achieve these goals. See the runtime manifest and image for detailed requirements. Practically speaking, our tool containerit may help you in creating a first Dockerfile and then make necessary adjustments, e.g. installing a dependency from an unsupported source. It is important that the Dockerfile includes a command that creates the display file from the main file, i.e. executing the workflow and rendering of the output document, and uses a suitable working directory within the container. The working directory is important to support features such as file substitution. The following Dockerfile snippet switches to the required working /erc directory and uses rmarkdown::render(..) to generate the display file display.html (output to the working directory, just to be sure) from the main file main.Rmd . WORKDIR /erc/ CMD [ \"R\" , \"--vanilla\" , \"-e\" , \"rmarkdown::render( input = \\\" /erc/main.Rmd \\\" , output_format = rmarkdown::html_document () , output_dir = \\\" /erc \\\" , output_file = \\\" display.html \\\" ) \"] Step 3: create metadata \u00b6 ERC metadata \u00b6 Structural & administrative metadata must be put into the ERC configuration file erc.yml as defined in the specification . When creating the erc manually, you can receive a uuid4 as id for the erc configuration file using an online service, e.g. uuidgenerator or one of the numerous implementations for the common programming languages. License metadata \u00b6 Please consult your employer or legal department for a suitable license for your work. Make sure you hold the copyright for any code that you want to release under a self-chosen license and that the license is compatible with the conditions of licenses of used data or software. A good discussion of the legal aspects of reproducible research is given in Victoria Stodden\u2019s \u201cThe Legal Framework for Reproducible Scientific Research: Licensing and Copyright\u201d ( public preprint ) . Further resources that are linked here without any endorsement or being checked: choosealicense.com (for code) opendefinition.org (for code, data, text) A short lecture on Open Licensing by Lorena A. Barba License information must be put into the ERC configuration file erc.yml as defined in the specification . Content metadata \u00b6 Content metadata are used for making your work findable. Properties for the content metadata are defined in the specification and must be put into the metadata.json file. Secondary metadata \u00b6 As of now, we do not recommend creating secondary metadata by hand. Secondary metadata are used for third party services, e.g. repositories that define their own obligatory metadata. In general they can be added in different formats to support different use cases and they should be stored in a directory .erc . More information on secondary metadata can be found in the preservation section . Step 4: validate \u00b6 You can use the container created in step 2 for validation purposes, too. Run the analysis in the container, then copy the analysis output to a temporary directory on the host system, and finally compare the original workspace and the temporary directory according the validation rules to ensure a complete replication. Step 5: create bag \u00b6 To create a package that is suitable for being stored in an archive or repository, ERCs must be bundled as BagIt bags. Take a look at the preservation section for a detailed background about the purpose of BagIt and other digital preservation aspects. Third party tools for creating BagIt bags \u00b6 Bagger (version 2.7, Java-based, with UI) bagit-python (Python package) Creating the bag \u00b6 In this guide we will create the bag manually by using the Library of Congress\u2019s (LoC) tool Bagger , listed above. Start by selecting \u201cCreate new bag\u201d from the main menu and proceed with \u201c<no profile>\u201c. Add your files with the \u201c+\u201d Button. Uncheck the \u201cStandard\u201d feature in the Bag-Info-Editor on the right and add ERC-Version with the appropriate version you want to use, e.g. 1 . Optionally fill out additional Bag-Info metadata, e.g. contact information . Save your bag using the main menu. Validating the bag \u00b6 A file tree for the final bagged ERC may look like this: \u251c\u2500\u2500 bag-info.txt \u251c\u2500\u2500 bagit.txt \u251c\u2500\u2500 data \u2502 \u251c\u2500\u2500 .erc/metadata.json \u2502 \u251c\u2500\u2500 erc.yml \u2502 \u251c\u2500\u2500 manuscript.Rmd \u2502 \u251c\u2500\u2500 display.html \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u2514\u2500\u2500 image.tar \u251c\u2500\u2500 manifest-md5.txt \u2514\u2500\u2500 tagmanifest-md5.txt You can validate your bag with Bagger by loading the bag and then clicking on \u201cValidate Bag\u201d in the main menu. The programme will check for completeness of BagIt-related files and verify the integrity of the data files by computing their checksums (hashes) and report any potential issues.","title":"Creation guide for authors"},{"location":"user-guide/creation/#user-guide-erc-creation","text":"This user guide comprises instructions how to create an ERC by hand . It is thus limited to mandatory elements in some places. However, a fundamental goal of the ERC specification is to be simple enough to allow manual ERC creation as demonstrated in this document. It is supposed to ease the understanding of the ERC especially for the authors of scientific publications. For using tools or services for creation and validation of ERCs, please see the developer guide . Note This is a draft. If you have comments or suggestions please file them in the issue tracker . If you have explicit changes please fork the git repo and submit a pull request.","title":"User guide: ERC creation"},{"location":"user-guide/creation/#step-1-create-workspace","text":"Do your research and create something useful that works for you. The ERC specification makes no restrictions on the contents of a workspace, but guidelines and best practices do exist and should be followed by users during their research i.e. even before packaging it in an ERC.","title":"Step 1: create workspace"},{"location":"user-guide/creation/#code-and-versioning","text":"If the base directory contains a script file or source code used to conduct the packaged analysis, we recommend this code is managed using distributed version control , see software carpentry guidelines . The base directory should contain a copy of the complete repository in that case.","title":"Code and versioning"},{"location":"user-guide/creation/#workspace-structure","text":"The base directory contents should follow common guidelines to project organisation. Some useful resources are Software carpentry paper \u201cGood enough practices in Scientific Computing\u201d ROpenSci research compendium ). ROpenSci reproducibility guide","title":"Workspace structure"},{"location":"user-guide/creation/#step-2-create-image-container-for-runtime","text":"To create a working ERC you must include a complete environment description and an executable image. We recommend using Docker, so a Dockerfile and a Docker image tarball archive file, to achieve these goals. See the runtime manifest and image for detailed requirements. Practically speaking, our tool containerit may help you in creating a first Dockerfile and then make necessary adjustments, e.g. installing a dependency from an unsupported source. It is important that the Dockerfile includes a command that creates the display file from the main file, i.e. executing the workflow and rendering of the output document, and uses a suitable working directory within the container. The working directory is important to support features such as file substitution. The following Dockerfile snippet switches to the required working /erc directory and uses rmarkdown::render(..) to generate the display file display.html (output to the working directory, just to be sure) from the main file main.Rmd . WORKDIR /erc/ CMD [ \"R\" , \"--vanilla\" , \"-e\" , \"rmarkdown::render( input = \\\" /erc/main.Rmd \\\" , output_format = rmarkdown::html_document () , output_dir = \\\" /erc \\\" , output_file = \\\" display.html \\\" ) \"]","title":"Step 2: create image container for runtime"},{"location":"user-guide/creation/#step-3-create-metadata","text":"","title":"Step 3: create metadata"},{"location":"user-guide/creation/#erc-metadata","text":"Structural & administrative metadata must be put into the ERC configuration file erc.yml as defined in the specification . When creating the erc manually, you can receive a uuid4 as id for the erc configuration file using an online service, e.g. uuidgenerator or one of the numerous implementations for the common programming languages.","title":"ERC metadata"},{"location":"user-guide/creation/#license-metadata","text":"Please consult your employer or legal department for a suitable license for your work. Make sure you hold the copyright for any code that you want to release under a self-chosen license and that the license is compatible with the conditions of licenses of used data or software. A good discussion of the legal aspects of reproducible research is given in Victoria Stodden\u2019s \u201cThe Legal Framework for Reproducible Scientific Research: Licensing and Copyright\u201d ( public preprint ) . Further resources that are linked here without any endorsement or being checked: choosealicense.com (for code) opendefinition.org (for code, data, text) A short lecture on Open Licensing by Lorena A. Barba License information must be put into the ERC configuration file erc.yml as defined in the specification .","title":"License metadata"},{"location":"user-guide/creation/#content-metadata","text":"Content metadata are used for making your work findable. Properties for the content metadata are defined in the specification and must be put into the metadata.json file.","title":"Content metadata"},{"location":"user-guide/creation/#secondary-metadata","text":"As of now, we do not recommend creating secondary metadata by hand. Secondary metadata are used for third party services, e.g. repositories that define their own obligatory metadata. In general they can be added in different formats to support different use cases and they should be stored in a directory .erc . More information on secondary metadata can be found in the preservation section .","title":"Secondary metadata"},{"location":"user-guide/creation/#step-4-validate","text":"You can use the container created in step 2 for validation purposes, too. Run the analysis in the container, then copy the analysis output to a temporary directory on the host system, and finally compare the original workspace and the temporary directory according the validation rules to ensure a complete replication.","title":"Step 4: validate"},{"location":"user-guide/creation/#step-5-create-bag","text":"To create a package that is suitable for being stored in an archive or repository, ERCs must be bundled as BagIt bags. Take a look at the preservation section for a detailed background about the purpose of BagIt and other digital preservation aspects.","title":"Step 5: create bag"},{"location":"user-guide/creation/#third-party-tools-for-creating-bagit-bags","text":"Bagger (version 2.7, Java-based, with UI) bagit-python (Python package)","title":"Third party tools for creating BagIt bags"},{"location":"user-guide/creation/#creating-the-bag","text":"In this guide we will create the bag manually by using the Library of Congress\u2019s (LoC) tool Bagger , listed above. Start by selecting \u201cCreate new bag\u201d from the main menu and proceed with \u201c<no profile>\u201c. Add your files with the \u201c+\u201d Button. Uncheck the \u201cStandard\u201d feature in the Bag-Info-Editor on the right and add ERC-Version with the appropriate version you want to use, e.g. 1 . Optionally fill out additional Bag-Info metadata, e.g. contact information . Save your bag using the main menu.","title":"Creating the bag"},{"location":"user-guide/creation/#validating-the-bag","text":"A file tree for the final bagged ERC may look like this: \u251c\u2500\u2500 bag-info.txt \u251c\u2500\u2500 bagit.txt \u251c\u2500\u2500 data \u2502 \u251c\u2500\u2500 .erc/metadata.json \u2502 \u251c\u2500\u2500 erc.yml \u2502 \u251c\u2500\u2500 manuscript.Rmd \u2502 \u251c\u2500\u2500 display.html \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u2514\u2500\u2500 image.tar \u251c\u2500\u2500 manifest-md5.txt \u2514\u2500\u2500 tagmanifest-md5.txt You can validate your bag with Bagger by loading the bag and then clicking on \u201cValidate Bag\u201d in the main menu. The programme will check for completeness of BagIt-related files and verify the integrity of the data files by computing their checksums (hashes) and report any potential issues.","title":"Validating the bag"},{"location":"user-guide/erc_journal_supplement/","text":"User guide: the ERC as journal supplement \u00b6 To facilitate integration into open access journals, the ERC can serve as a supplement to a journal article. In that use case a supplement would not contain the full text of the publication but be attached to or linked from an article instead. While this increases storage size (each ERC must contain all required data and software), introduces duplication (e.g. in the metadata) and spreads out related artifacts (e.g. if each supplement is stored in an independent repository item), it considerably simplifies integration with existing workflows and practices, namely by licensing and storing the supplemental material independently from the article, by not impacting the existing article rendering solution (e.g. static HTML or PDF), and by reducing the impact on the established review and production workflow. When the ERC is attached as supplement, it is important to make sure the results are still findable, accessible, interoperable, and reusable, following the FAIR principles. A supplemental ERC should most importantly reference the main article via its DOI. An ERC as supplement must still be a formally complete ERC and as such it satisfies important requirements of reproducible research. Example A publication contains three figures with data plots. Two approaches are possible: each of the figures is encapsulated in a minimal ERC containing the needed data, an R script, the rendered figure as a grphic (e.g. a PNG), and its own runtime environment; or all figures are embedded in an R Markdown document, including the article abstract, figure titles, and figure description, and share data files and the runtime environment. The latter approach is more user friendly because explanatory context is provided and the HTML-based display file directly supports UI bindings. Read more on the increasing importance of reproducible supplements scientific records in Greenbaum et al. 2017 . If ERCs are published on data repositories or collaboration platforms, they should be tagged as research-compendium following the conventions of https://research-compendium.science/ .","title":"ERC as supplement"},{"location":"user-guide/erc_journal_supplement/#user-guide-the-erc-as-journal-supplement","text":"To facilitate integration into open access journals, the ERC can serve as a supplement to a journal article. In that use case a supplement would not contain the full text of the publication but be attached to or linked from an article instead. While this increases storage size (each ERC must contain all required data and software), introduces duplication (e.g. in the metadata) and spreads out related artifacts (e.g. if each supplement is stored in an independent repository item), it considerably simplifies integration with existing workflows and practices, namely by licensing and storing the supplemental material independently from the article, by not impacting the existing article rendering solution (e.g. static HTML or PDF), and by reducing the impact on the established review and production workflow. When the ERC is attached as supplement, it is important to make sure the results are still findable, accessible, interoperable, and reusable, following the FAIR principles. A supplemental ERC should most importantly reference the main article via its DOI. An ERC as supplement must still be a formally complete ERC and as such it satisfies important requirements of reproducible research. Example A publication contains three figures with data plots. Two approaches are possible: each of the figures is encapsulated in a minimal ERC containing the needed data, an R script, the rendered figure as a grphic (e.g. a PNG), and its own runtime environment; or all figures are embedded in an R Markdown document, including the article abstract, figure titles, and figure description, and share data files and the runtime environment. The latter approach is more user friendly because explanatory context is provided and the HTML-based display file directly supports UI bindings. Read more on the increasing importance of reproducible supplements scientific records in Greenbaum et al. 2017 . If ERCs are published on data repositories or collaboration platforms, they should be tagged as research-compendium following the conventions of https://research-compendium.science/ .","title":"User guide: the ERC as journal supplement"},{"location":"user-guide/examination/","text":"User guide: ERC examination \u00b6 An Executable Research Compendium (ERC) can be examined using a supporting user interface or, in lack of such a tool or for higher control, manually . UI-based \u00b6 The o2r platform provides an interactive user interface for examination of an ERC . The right-hand side of the start page provides a form to load a complete executable research compendium. Screenshot of o2r platform: home page. The following sources and identifiers are supported: an identifier of an ERC available in the reproducibility service at hand a DOI or full repository URL of a supported data repository a repository-specific identifier of a supported data repository Note The demonstrator is only configured to ship (store) ERC to Zenodo Sandbox , therefore examination starting from DOIs is not commonly available because Zenodo Sandbox does not provide valid DOIs. A user may upload a valid compendium to \u201cregular\u201d Zenodo manually and then examine via a DOI. Currently you must be locked in, as other security mechanisms are out of scope of the demonstration prototype. Screenshot of o2r platform: home page with logged-in user and filled out examination form. After loading the ERC from the reproducibility service\u2019s database and file cache or from the data repository, you are taken to a compendium landing page and can continue with different aspects of examination : Screenshot of o2r platform: ERC detail page, the \"green\" comparison button points out a successful reproduction. check to run an analysis, i.e. ensure computational reproducibility inspect to closely evaluate core code and data files manipulate to adjust selected parameters when executing the computations substitute to switch out data or code files re-run computations Check, manipulation, and substitution allow readers to interact with the packaged workflow. Manipulation options are based on the bindings provided as part of the compendium. All these interactions result in a new output, the reproduced display file . It can be compared with the original display file included in the compendium. The following screenshot shows the visual aid for comparison provided by the UI. Screenshot of o2r platform: check comparison view with differences in figure highlighted, e.g. after substitution or manipulation. Furthermore you can examine the log files of the execution in the job log on the right hand side. Manual \u00b6 Nothing lasts forever . While it is reasonable to assume that an ERC-based publication workflow is maintainable for some time (cf. developer guide on ERC lifespan , the ERC concept also supports a manual examination. The ready-to-use user interface provided by the o2r project provides user-friendliness and shortcuts, but the same results can be achieved manually. Of course this requires a higher level of expertise in the underlying tools. The following sections mimic the steps conducted by the reproducibility service to load and examine a valid ERC. Download and extract \u00b6 Download the ERC from a data repository to your local machine. Screenshot of Zenodo record landing page with preview of contents of the downloadable archive file, in this case `PPhqW.zip`. Then extract the archive. You may familiarise yourself with the BagIt specification , but you mostly just need to open the payload directory, data , in the extracted bag. Validate \u00b6 The following checks can be made to ensure an ERC is valid: presence of mandatory files in the payload directory: erc.yml , Dockerfile , image.tar(.gz) the whole bag is valid, check e.g. with the bagit Python library Examine \u00b6 Inspect \u00b6 Open the file erc.yml with a text viewer. It is the entrypoint to an ERC both for software tools and humans. The most important information in it is which files are the main file and the display file . Open the main file in a suitable viewer, e.g. a web browser for an HTML file, and the display file in a suitable viewer or editor. The erc.yml further lists the licenses for each part of the compendium. Make sure your usage of the Secondary, but potentially very useful information, can be found in the .erc directory. It contains log files from the creation of the compendium and metadata in different formats. These files can be helpful to investigate provenance and authorship of a compendium. Examine runtime \u00b6 The runtime is defined in two levels: a manifest describing the construction of the image . The manifest, probably a Dockerfile , is readable both for humans and machines. You can study the specification for the used manifest type and then understand all commands which were used to create the original computational environment. The image, probably image.tar , is a tarball of all files and directories making up the runtime environment. You can study the image format specification, e.g. Docker Image Specification v1.2.0 (assumed for the remainder of this section), to understand the contents of the tarball. Extract the tarball it to inspect the contained software, be it binaries, source files, or configurations. The image also contains helpful metadata. A file manifest.json describes the lay ers of the image. The layers themselves are composed of a tarball with the files ( layer.tar ), which are layed over the lower layers, and metadata. A file <image hash>.json includes metadata about the architecture and operating system the image was created on, the configuration, and a representation of all steps in the manifest (see the history object) that lead to the creation of the image and its layers. Check \u00b6 You may now run the workflow by executing the main file. You have a choice of potential runtime environments: Your computer, using the locally installed software packages and system packages Recreate the runtime environment based on the runtime manifest Load and run the runtime image from the ERC The first approach is the most direct one, and if the results are the same, you can be quite sure the workflow is stable and reproducible. Follow the instructions included in the main file or use well-known commands to compile the main file with the appropriate tools. The last approach is closest to the environment that the original author had; this approach is used by the reproducibility service. You must manually extract the reproduced display file from the container after running it. In all approaches, after you have created the display file, you can compare it to the original, e.g. by opening them side by side. You can also use tools to assist the comparison: diff CLI tool can compare the original and reproduced display file, if they are text-based erc-checker , the tool used within the reproducibility service, can be installed with npm and run locally to compare both texts and embedded images Manipulate & substitute \u00b6 You can use the bindings specified in the erc.yml to identify core parameters in the main file or other script files of the compendium and manually change these when compiling the document. Alternatively you can read through all code (starting with the main file), understand it, and change it as whished. Substitution can also be done manually by changing the file paths in the instructions loading data files. Tip You can initialise a local code repository after extracting the download to trace your changes, e.g. with git diff . Changing code and data is easiest when using a local environment, but also possible for the included runtime image by using bind mounts when running the image. Detailed examination of code and text \u00b6 This guide can not go into detail about examining the actual code, data, and text content and therefore ends at this stage. Such a detailed level of examination is domain-specific. However, a generic guide for the consumption of (executable) research compendia is published as part of the research-compendium.science initiative: N\u00fcst, Daniel, Carl Boettiger, and Ben Marwick. 2018. \u201cHow to read a research compendium.\u201d arXiv:1806.09525 [cs.GL].","title":"Examination guide for readers and reviewers"},{"location":"user-guide/examination/#user-guide-erc-examination","text":"An Executable Research Compendium (ERC) can be examined using a supporting user interface or, in lack of such a tool or for higher control, manually .","title":"User guide: ERC examination"},{"location":"user-guide/examination/#ui-based","text":"The o2r platform provides an interactive user interface for examination of an ERC . The right-hand side of the start page provides a form to load a complete executable research compendium. Screenshot of o2r platform: home page. The following sources and identifiers are supported: an identifier of an ERC available in the reproducibility service at hand a DOI or full repository URL of a supported data repository a repository-specific identifier of a supported data repository Note The demonstrator is only configured to ship (store) ERC to Zenodo Sandbox , therefore examination starting from DOIs is not commonly available because Zenodo Sandbox does not provide valid DOIs. A user may upload a valid compendium to \u201cregular\u201d Zenodo manually and then examine via a DOI. Currently you must be locked in, as other security mechanisms are out of scope of the demonstration prototype. Screenshot of o2r platform: home page with logged-in user and filled out examination form. After loading the ERC from the reproducibility service\u2019s database and file cache or from the data repository, you are taken to a compendium landing page and can continue with different aspects of examination : Screenshot of o2r platform: ERC detail page, the \"green\" comparison button points out a successful reproduction. check to run an analysis, i.e. ensure computational reproducibility inspect to closely evaluate core code and data files manipulate to adjust selected parameters when executing the computations substitute to switch out data or code files re-run computations Check, manipulation, and substitution allow readers to interact with the packaged workflow. Manipulation options are based on the bindings provided as part of the compendium. All these interactions result in a new output, the reproduced display file . It can be compared with the original display file included in the compendium. The following screenshot shows the visual aid for comparison provided by the UI. Screenshot of o2r platform: check comparison view with differences in figure highlighted, e.g. after substitution or manipulation. Furthermore you can examine the log files of the execution in the job log on the right hand side.","title":"UI-based"},{"location":"user-guide/examination/#manual","text":"Nothing lasts forever . While it is reasonable to assume that an ERC-based publication workflow is maintainable for some time (cf. developer guide on ERC lifespan , the ERC concept also supports a manual examination. The ready-to-use user interface provided by the o2r project provides user-friendliness and shortcuts, but the same results can be achieved manually. Of course this requires a higher level of expertise in the underlying tools. The following sections mimic the steps conducted by the reproducibility service to load and examine a valid ERC.","title":"Manual"},{"location":"user-guide/examination/#download-and-extract","text":"Download the ERC from a data repository to your local machine. Screenshot of Zenodo record landing page with preview of contents of the downloadable archive file, in this case `PPhqW.zip`. Then extract the archive. You may familiarise yourself with the BagIt specification , but you mostly just need to open the payload directory, data , in the extracted bag.","title":"Download and extract"},{"location":"user-guide/examination/#validate","text":"The following checks can be made to ensure an ERC is valid: presence of mandatory files in the payload directory: erc.yml , Dockerfile , image.tar(.gz) the whole bag is valid, check e.g. with the bagit Python library","title":"Validate"},{"location":"user-guide/examination/#examine","text":"","title":"Examine"},{"location":"user-guide/examination/#inspect","text":"Open the file erc.yml with a text viewer. It is the entrypoint to an ERC both for software tools and humans. The most important information in it is which files are the main file and the display file . Open the main file in a suitable viewer, e.g. a web browser for an HTML file, and the display file in a suitable viewer or editor. The erc.yml further lists the licenses for each part of the compendium. Make sure your usage of the Secondary, but potentially very useful information, can be found in the .erc directory. It contains log files from the creation of the compendium and metadata in different formats. These files can be helpful to investigate provenance and authorship of a compendium.","title":"Inspect"},{"location":"user-guide/examination/#examine-runtime","text":"The runtime is defined in two levels: a manifest describing the construction of the image . The manifest, probably a Dockerfile , is readable both for humans and machines. You can study the specification for the used manifest type and then understand all commands which were used to create the original computational environment. The image, probably image.tar , is a tarball of all files and directories making up the runtime environment. You can study the image format specification, e.g. Docker Image Specification v1.2.0 (assumed for the remainder of this section), to understand the contents of the tarball. Extract the tarball it to inspect the contained software, be it binaries, source files, or configurations. The image also contains helpful metadata. A file manifest.json describes the lay ers of the image. The layers themselves are composed of a tarball with the files ( layer.tar ), which are layed over the lower layers, and metadata. A file <image hash>.json includes metadata about the architecture and operating system the image was created on, the configuration, and a representation of all steps in the manifest (see the history object) that lead to the creation of the image and its layers.","title":"Examine runtime"},{"location":"user-guide/examination/#check","text":"You may now run the workflow by executing the main file. You have a choice of potential runtime environments: Your computer, using the locally installed software packages and system packages Recreate the runtime environment based on the runtime manifest Load and run the runtime image from the ERC The first approach is the most direct one, and if the results are the same, you can be quite sure the workflow is stable and reproducible. Follow the instructions included in the main file or use well-known commands to compile the main file with the appropriate tools. The last approach is closest to the environment that the original author had; this approach is used by the reproducibility service. You must manually extract the reproduced display file from the container after running it. In all approaches, after you have created the display file, you can compare it to the original, e.g. by opening them side by side. You can also use tools to assist the comparison: diff CLI tool can compare the original and reproduced display file, if they are text-based erc-checker , the tool used within the reproducibility service, can be installed with npm and run locally to compare both texts and embedded images","title":"Check"},{"location":"user-guide/examination/#manipulate-substitute","text":"You can use the bindings specified in the erc.yml to identify core parameters in the main file or other script files of the compendium and manually change these when compiling the document. Alternatively you can read through all code (starting with the main file), understand it, and change it as whished. Substitution can also be done manually by changing the file paths in the instructions loading data files. Tip You can initialise a local code repository after extracting the download to trace your changes, e.g. with git diff . Changing code and data is easiest when using a local environment, but also possible for the included runtime image by using bind mounts when running the image.","title":"Manipulate &amp; substitute"},{"location":"user-guide/examination/#detailed-examination-of-code-and-text","text":"This guide can not go into detail about examining the actual code, data, and text content and therefore ends at this stage. Such a detailed level of examination is domain-specific. However, a generic guide for the consumption of (executable) research compendia is published as part of the research-compendium.science initiative: N\u00fcst, Daniel, Carl Boettiger, and Ben Marwick. 2018. \u201cHow to read a research compendium.\u201d arXiv:1806.09525 [cs.GL].","title":"Detailed examination of code and text"},{"location":"user-guide/minimal/","text":"Minimal examples for ERCs \u00b6 R script with png plot R Markdown with HTML output R script with png plot \u00b6 Main file main.R \u00b6 # http://www.budgetshippingcontainers.co.uk/info/ # how-many-shipping-containers-are-there-in-the-world/ containers <- c ( 23000000 , 14000000 , 6000000 ) set.seed ( 42 ) barplot ( containers , names.arg = c ( \"in service\" , \"ex-service\" , \"new\" ), col = sample ( colors (), 3 ), main = paste0 ( format ( sum ( containers ), scientific = FALSE ), \" containers in the world\" ) ) Display file display.png \u00b6 ERC configuration file \u00b6 --- id: \"289a9jcl9o\" spec_version: \"1\" main: main.R display: display.png R Markdown with HTML output \u00b6 Main file main.Rmd \u00b6 --- title: \"Capacity of container ships in seaborne trade from 1980 to 2016 (in million dwt)*\" author: \"Daniel N\u00fcst\" date: \"2017\" output: html_document --- ```{r plot, echo=FALSE} data <- c(\"1980\" = 11, \"1985\" = 20, \"1990\" = 26, \"1995\" = 44, \"2000\" = 64, \"2005\" = 98, \"2010\" = 169, \"2014\" = 216, \"2015\" = 228, \"2016\" = 244) barplot(data, ylab = \"Capacity\", sub = \"\u00a9 Statista 2017\") ``` > This statistic portrays the capacity of the world container ship fleet from 1980 through 2016. In 2016, the world merchant container ship fleet had a capacity of around 244 million metric tons deadweight. As of January 2016, there were 5,239 container ships in the world's merchant fleet ([source](https://www.statista.com/statistics/264024/number-of-merchant-ships-worldwide-by-type/)). Sources: UNCTAD; Clarkson Research Services, via [ statista ]( https://www.statista.com/statistics/267603/capacity-of-container-ships-in-the-global-seaborne-trade/ ). Display file display.html \u00b6 HTML ERC configuration file \u00b6 --- id: \"v97cplst6b\" spec_version: \"1\" main: main.Rmd display: display.html","title":"Minimal ERC examples"},{"location":"user-guide/minimal/#minimal-examples-for-ercs","text":"R script with png plot R Markdown with HTML output","title":"Minimal examples for ERCs"},{"location":"user-guide/minimal/#r-script-with-png-plot","text":"","title":"R script with png plot"},{"location":"user-guide/minimal/#main-file-mainr","text":"# http://www.budgetshippingcontainers.co.uk/info/ # how-many-shipping-containers-are-there-in-the-world/ containers <- c ( 23000000 , 14000000 , 6000000 ) set.seed ( 42 ) barplot ( containers , names.arg = c ( \"in service\" , \"ex-service\" , \"new\" ), col = sample ( colors (), 3 ), main = paste0 ( format ( sum ( containers ), scientific = FALSE ), \" containers in the world\" ) )","title":"Main file main.R"},{"location":"user-guide/minimal/#display-file-displaypng","text":"","title":"Display file display.png"},{"location":"user-guide/minimal/#erc-configuration-file","text":"--- id: \"289a9jcl9o\" spec_version: \"1\" main: main.R display: display.png","title":"ERC configuration file"},{"location":"user-guide/minimal/#r-markdown-with-html-output","text":"","title":"R Markdown with HTML output"},{"location":"user-guide/minimal/#main-file-mainrmd","text":"--- title: \"Capacity of container ships in seaborne trade from 1980 to 2016 (in million dwt)*\" author: \"Daniel N\u00fcst\" date: \"2017\" output: html_document --- ```{r plot, echo=FALSE} data <- c(\"1980\" = 11, \"1985\" = 20, \"1990\" = 26, \"1995\" = 44, \"2000\" = 64, \"2005\" = 98, \"2010\" = 169, \"2014\" = 216, \"2015\" = 228, \"2016\" = 244) barplot(data, ylab = \"Capacity\", sub = \"\u00a9 Statista 2017\") ``` > This statistic portrays the capacity of the world container ship fleet from 1980 through 2016. In 2016, the world merchant container ship fleet had a capacity of around 244 million metric tons deadweight. As of January 2016, there were 5,239 container ships in the world's merchant fleet ([source](https://www.statista.com/statistics/264024/number-of-merchant-ships-worldwide-by-type/)). Sources: UNCTAD; Clarkson Research Services, via [ statista ]( https://www.statista.com/statistics/267603/capacity-of-container-ships-in-the-global-seaborne-trade/ ).","title":"Main file main.Rmd"},{"location":"user-guide/minimal/#display-file-displayhtml","text":"HTML","title":"Display file display.html"},{"location":"user-guide/minimal/#erc-configuration-file_1","text":"--- id: \"v97cplst6b\" spec_version: \"1\" main: main.Rmd display: display.html","title":"ERC configuration file"},{"location":"user-guide/oais/","text":"ERC preservation aspects in the light of OAIS \u00b6 The Open Archival Information System (OAIS) reference model is a framework for the preservation and dissemination of digital objects (assets). It has been created by the Consultative Committee for Space Data Systems (CCSDS) and has since been adopted by a wide range of international institutions. The OAIS provides the terminology and concept of the information package as primitive of the digital preservation workflow. Submission information packages (SIP), Dissemination information packages (DIP) and Archival information packages (AIP) refer to different functional roles and stages of a digital object within long term preservation. Where does the ERC fit into long term preservation? ERCs contain software. They could be abstracted as recipes for the reproduction of a scientific analysis be it a stand alone version or a supplement for a scholarly paper. As such every ERC has a bit stream aspect and is suitable for digital preservation in general. But the ERC was also specifically designed to be represented as an information package in the sense of the OAIS model: the data inside the ERC are valid Bagit bags, making it easy to validate their bitwise integrity with checksums. Additionally the ERC comprises several facets of metadata and a governing \u201cpackage slip\u201d that preserves the standards and schemas used for these metadata. The elicitation of metadata as well as the creation of valid Bagit bags are fully integrated into the creation process of the ERC. Interpretability of the archived software \u00b6 The representation information object within OAIS consists of structural and semantic information and is itself linked to other units of representation information, building a representation network. The information contained within the ERC and its metadata serves as representation information and enables the interpretability of the archived software, environment, code, data, text and UI bindings. Standards used for representation are included as local copy of the underlying schema and as reference to their persistent identifiers. The network of information objects describes how the parts of the ERC relate to each other and how they are to be used and understood. By providing a \u201cpackage slip\u201d for the standards and schemas used in the ERC a vital step for the preservation of software interpretability is completed. As the ERC is designed to transport every information necessary to recreate the original piece of software as represented by a scientific workspace to serve as supplement for a publication or as a repository publication itself, there is often several metadata standards involved (e.g. Datacite, Codemeta, \u2026). The long term interpretability of these information is ensured by including the metadata and their governing schemas on a second order meta level. They allow for interpreting the original data, but also the semantics of the metadata elements describing the original data assets. The concept of archival interpretability adds significant scientific value as it enables multi-level reproducibility and addionally a future historical perspective on the scientific analysis of today. References \u00b6 CCSDS (2012): RECOMMENDED PRACTICE FOR AN OAIS REFERENCE MODEL. CCSDS 650.0-M-2 (Magenta Book). http://public.ccsds.org/publications/archive/650x0m2.pdf Maack, M.N. (2015). The Open Archival Information System (oais) Reference Model.","title":"ERC & OAIS"},{"location":"user-guide/oais/#erc-preservation-aspects-in-the-light-of-oais","text":"The Open Archival Information System (OAIS) reference model is a framework for the preservation and dissemination of digital objects (assets). It has been created by the Consultative Committee for Space Data Systems (CCSDS) and has since been adopted by a wide range of international institutions. The OAIS provides the terminology and concept of the information package as primitive of the digital preservation workflow. Submission information packages (SIP), Dissemination information packages (DIP) and Archival information packages (AIP) refer to different functional roles and stages of a digital object within long term preservation. Where does the ERC fit into long term preservation? ERCs contain software. They could be abstracted as recipes for the reproduction of a scientific analysis be it a stand alone version or a supplement for a scholarly paper. As such every ERC has a bit stream aspect and is suitable for digital preservation in general. But the ERC was also specifically designed to be represented as an information package in the sense of the OAIS model: the data inside the ERC are valid Bagit bags, making it easy to validate their bitwise integrity with checksums. Additionally the ERC comprises several facets of metadata and a governing \u201cpackage slip\u201d that preserves the standards and schemas used for these metadata. The elicitation of metadata as well as the creation of valid Bagit bags are fully integrated into the creation process of the ERC.","title":"ERC preservation aspects in the light of OAIS"},{"location":"user-guide/oais/#interpretability-of-the-archived-software","text":"The representation information object within OAIS consists of structural and semantic information and is itself linked to other units of representation information, building a representation network. The information contained within the ERC and its metadata serves as representation information and enables the interpretability of the archived software, environment, code, data, text and UI bindings. Standards used for representation are included as local copy of the underlying schema and as reference to their persistent identifiers. The network of information objects describes how the parts of the ERC relate to each other and how they are to be used and understood. By providing a \u201cpackage slip\u201d for the standards and schemas used in the ERC a vital step for the preservation of software interpretability is completed. As the ERC is designed to transport every information necessary to recreate the original piece of software as represented by a scientific workspace to serve as supplement for a publication or as a repository publication itself, there is often several metadata standards involved (e.g. Datacite, Codemeta, \u2026). The long term interpretability of these information is ensured by including the metadata and their governing schemas on a second order meta level. They allow for interpreting the original data, but also the semantics of the metadata elements describing the original data assets. The concept of archival interpretability adds significant scientific value as it enables multi-level reproducibility and addionally a future historical perspective on the scientific analysis of today.","title":"Interpretability of the archived software"},{"location":"user-guide/oais/#references","text":"CCSDS (2012): RECOMMENDED PRACTICE FOR AN OAIS REFERENCE MODEL. CCSDS 650.0-M-2 (Magenta Book). http://public.ccsds.org/publications/archive/650x0m2.pdf Maack, M.N. (2015). The Open Archival Information System (oais) Reference Model.","title":"References"},{"location":"user-guide/template/","text":"User guide: ERC template - WORK IN PROGRESS \u00b6 If you want to create an ERC for your research already at the beginning, and not \u201cpost-hoc\u201d after your research is complete, these templates can hopefully help. They are divided into specific domains to be more concrete. Geoscience research in R \u00b6 Files in this template document.md use RMarkdown, this is the main document erc.yml is template for the ERC configuration file with placeholders for all required fields Dockerfile is a template Dockerfile with some commands you can re-use to make sure all packages and tools that you need are installed Header template \u00b6 The yaml header of the document.md file is the right place to enter your meta information right away from the start: Fill out the metadata fields, included in the template, as early in your personal workflow as possible and keep them up-to-date to prepare for the ERC creation progress. The metadata extractor of the o2r service will collect and prefer information from RMarkdown document headers. --- author: - name: Your Name affiliation: Your affiliation orcid: Your ORCid - name: Your co-author's name affiliation: Their affiliation orcid: Their ORCid title: The title of your publication abstract: A concise description of your publication keywords: [lorem, ipsum, dolor, sit, amet] date: 2017-01-13 license: text: cc-by code: GPLv2 data: \"public domain\" metadata: CC0 --- Filename | Template | ERC-Spec ------ | ------ | ------ | geo_template.zip | Geoscience research in R | V.1","title":"ERC template for authors"},{"location":"user-guide/template/#user-guide-erc-template-work-in-progress","text":"If you want to create an ERC for your research already at the beginning, and not \u201cpost-hoc\u201d after your research is complete, these templates can hopefully help. They are divided into specific domains to be more concrete.","title":"User guide: ERC template - WORK IN PROGRESS"},{"location":"user-guide/template/#geoscience-research-in-r","text":"Files in this template document.md use RMarkdown, this is the main document erc.yml is template for the ERC configuration file with placeholders for all required fields Dockerfile is a template Dockerfile with some commands you can re-use to make sure all packages and tools that you need are installed","title":"Geoscience research in R"},{"location":"user-guide/template/#header-template","text":"The yaml header of the document.md file is the right place to enter your meta information right away from the start: Fill out the metadata fields, included in the template, as early in your personal workflow as possible and keep them up-to-date to prepare for the ERC creation progress. The metadata extractor of the o2r service will collect and prefer information from RMarkdown document headers. --- author: - name: Your Name affiliation: Your affiliation orcid: Your ORCid - name: Your co-author's name affiliation: Their affiliation orcid: Their ORCid title: The title of your publication abstract: A concise description of your publication keywords: [lorem, ipsum, dolor, sit, amet] date: 2017-01-13 license: text: cc-by code: GPLv2 data: \"public domain\" metadata: CC0 --- Filename | Template | ERC-Spec ------ | ------ | ------ | geo_template.zip | Geoscience research in R | V.1","title":"Header template"}]}